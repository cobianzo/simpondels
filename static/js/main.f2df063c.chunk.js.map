{"version":3,"sources":["components/NextTurnButton.js","helpers.js","components/TopNav.js","components/Card.js","components/ActionButton.js","components/CardsDeck.js","components/Player.js","components/Players.js","components/Footer.js","components/Debug.js","components/App.js","serviceWorker.js","index.js"],"names":["NextTurnButton","hand","gameAPI","canMoveNext","can","className","onClick","moveToNextPlayerOrStage","shuffle","array","sort","Math","random","unique","value","index","self","indexOf","isEmpty","obj","key","hasOwnProperty","logg","string","rest","arguments","length","console","log","Array","from","join","logfn","fn_name","str","args","renderObject","jsx","Object","keys","TopNav","cards","currentPlayer","players","gameOptions","useState","open","name","must","initDemoGame","startGame","Card","card","place","allowedToBuild","cardsAPI","isBuyable","classes","type","is_killed","is_stolen","e","preventDefault","buildCard","ID","data-cardid","Fragment","src","alt","image","description","price","ActionButton","setHand","playersAPI","mustChooseCoinsOrCards","getCurrentStageParams","theCharacterCard","getCalledCharacterCard","handleCoinsOrCardsAction","action","clonedHand","assign","coinsOrCardsThisTurn","giveMoneyToPlayer","checkMoveToNextPlayerOrStage","pickUpCard","cardID","times","msg","messages","before_coins_or_cards_btn","msg_after","after_coins_or_cards_action","after_coins_or_cards_btn","btnClass","CardsDeck","characterCards","setCharacterCards","districtCards","setDistrictCards","setPlayers","removeRandomCharacterCard","clonedCardsArray","splice","floor","pickedCardsThisPlayerTurn","partialViewCharacter_1_and_2","charNum","eC","theKilledCardIndex","findIndex","c","getCardIndexByCharacterNumber","concat","filter","includes","getCardIndexByID","partialViewCharacter_3","class","tempDistrictCards","listCurrentPlayerCard","map","cardIndex","is_built","numberOfCards","updatePlayers","cc","ca","i","lastCard","pop","push","characterActThisTurn","setMessage","ci","player","playerIndex","privateCards","swapDistrictCardsBetweenPlayers","partialViewCharacter_4","partialViewCharacter_5","partialViewCharacter_6","partialViewCharacter_7","partialViewCharacter_8","playersStoleable","plyr","indx","playerHasCharacter","bishopPlayerIndex","getPlayerWhoOwnsCharacterCard","builtCards","destroyable","money","destroyBuiltCardByWarlord","handleCardClick","stage","minCardsToPickup","viewDistrictSelectionDeck","characterRound","parseInt","slice","lastIndexOf","viewCharacterSelectionDeck","theCard","characterAct","special_character_action_jsx","after_character_acts","playerCanBuild","viewWrapperCharacter","Player","crownPlayer","setCards","height","dCard","Players","wrapperClass","Footer","Debug","stages","dev","App","setCrownPlayer","number","builtCardsThisPlayerTurn","districtsBuiltThisPlayerCharacter","stageParamsThisTurn","setCurrentPlayer","temporaryMessage","loopPlayers","maxCardsToPickup","usePrevious","ref","useRef","useEffect","current","loadCards","initPlayers","allPlayers","pickedCardsInThisTurn","initDistrictOrCharacterDeck","alert","resetHandParams","moveToNextStage","nextStage","forEach","stageName","moveStage","nextPlayer","only_return_true_or_false","canMove","shouldMove","allowedToMove","forcedToMove","setUpCharacterSettings","characterNumber","kingPlayerIndex","characted2PlayerIndex","clonedPlayers","payPlayerByDistrictCardsType","a","url","window","location","origin","fetch","then","response","json","repeatTimes","newCard","getCardByID","getCardByCharacterNumber","typeOfCard","shuffleBool","deck","all_cards","all_players","getPlayerWhoOwnsDistrictCard","killCharacter","character_number","theCardToKillIndex","stealCharacter","theCardToStealIndex","grabLastDistrictCard","thePlayerIndex","playersUpdated","thePlayer","plyrIndx","coins","playrIndx","playersTemp","plIndx","districtType","districtCardsForThisCharacter","getBuildDistrictCardsForPlayerAndType","setPlayerWithCrownFirst","playersPrev","playerBuildableDictrictCards","is_build","player1Index","player2Index","thePlayer1Index","tempPlayers","tempPlayer1DistrictCards","playerDestroyed","playerIndexDestroyed","cardIndexDestroyed","currentCalledCard","warlordPlayerIndex","indexInPlayersCards","newPlayers","distritCardsAfterDestroy","newCards","getBuildDistrictCardsForPlayer","cardIndx","prevCurrentPlayer","giveTurnMoney","prevPickedCardsThisPlayerTurn","prevCharacterActThisTurn","prevcoinsOrCardsThisTurn","prevCanMoveNext","prevStage","playersX","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.f2df063c.chunk.js","sourcesContent":["// This is called in CardsDeck.js, inside fn viewWrapperCharacter(). \nimport React from 'react';\nimport '../css/NextTurnButton.scss';\n\nfunction NextTurnButton({  hand, gameAPI }) {\n\n  \n  const handleClick = () => {\n    gameAPI.moveToNextPlayerOrStage(); // it should alway be moveToNextPlayer()\n  }\n\n  // we show the button if: we can move to the next turn\n  if (hand.canMoveNext.can) {\n    return <button className=\"btn btn-danger mb-3\" onClick={handleClick}>\n      Next turn\n    </button>\n  }\n  return null;\n}\n\nexport default NextTurnButton;","import React from 'react'\n// HELPERS\n\n// shuffles an array by reference. Don't need to use the return value. Use: \n// @param array: the array we want to shuffle\n// @return the array, altough the array given as an arg is already shuffleed\nexport function shuffle(array) {\n  // one method:\n  array.sort(() => Math.random() - 0.5);\n  return array;\n}\n\n// works with array, use it with filter. ie: const uniqueAges = ages.filter(unique)\nexport function unique(value, index, self) {\n\treturn self.indexOf(value) === index\n}\n\n// tells if an object is empty like : {}\nexport function isEmpty(obj) {\n    for(var key in obj) {\n        if(obj.hasOwnProperty(key))\n            return false;\n    }\n    return true;\n}\n\n// NOT USED\n// compares two array (it might have objects or anything inside) or objects (can be nested)\n// and returns true if they have the same values.\nexport function isEqual(value, other) {\n\n\t// Get the value type\n\tvar type = Object.prototype.toString.call(value);\n\n\t// If the two objects are not the same type, return false\n\tif (type !== Object.prototype.toString.call(other)) return false;\n\n\t// If items are not an object or array, return false\n\tif (['[object Array]', '[object Object]'].indexOf(type) < 0) return false;\n\n\t// Compare the length of the length of the two items\n\tvar valueLen = type === '[object Array]' ? value.length : Object.keys(value).length;\n\tvar otherLen = type === '[object Array]' ? other.length : Object.keys(other).length;\n\tif (valueLen !== otherLen) return false;\n\n\t// Compare two items\n\tvar compare = function (item1, item2) {\n\n\t\t// Get the object type\n\t\tvar itemType = Object.prototype.toString.call(item1);\n\n\t\t// If an object or array, compare recursively\n\t\tif (['[object Array]', '[object Object]'].indexOf(itemType) >= 0) {\n\t\t\tif (!isEqual(item1, item2)) return false;\n\t\t}\n\n\t\t// Otherwise, do a simple comparison\n\t\telse {\n\n\t\t\t// If the two items are not the same type, return false\n\t\t\tif (itemType !== Object.prototype.toString.call(item2)) return false;\n\n\t\t\t// Else if it's a function, convert to a string and compare\n\t\t\t// Otherwise, just compare\n\t\t\tif (itemType === '[object Function]') {\n\t\t\t\tif (item1.toString() !== item2.toString()) return false;\n\t\t\t} else {\n\t\t\t\tif (item1 !== item2) return false;\n\t\t\t}\n\n\t\t}\n\t};\n\n\t// Compare properties\n\tif (type === '[object Array]') {\n\t\tfor (var i = 0; i < valueLen; i++) {\n\t\t\tif (compare(value[i], other[i]) === false) return false;\n\t\t}\n\t} else {\n\t\tfor (var key in value) {\n\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\tif (compare(value[key], other[key]) === false) return false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If nothing failed, return true\n\treturn true;\n\n};\n\n// function for dev purposes\nexport function logg( string, obj = null, ...rest) {\n\tif (arguments.length === 1 ) \n\t\tconsole.log(string);\n\tif (arguments.length === 2 ) \n\t\tconsole.log(string, obj);\n\tif (arguments.length > 2 ) \n\t\tconsole.log( Array.from(arguments).join(\" -||- \") );\n\treturn;\n}\n\nexport function logfn ( fn_name, ...args ) {\t\n\tconst str = `**** FN ${fn_name} ****`;\n\tlogg( str, ...args );\n}\n\nexport function renderObject(obj) {\n\tlet jsx = null;\n\tif (!obj) return '';\n\tfor ( let key of Object.keys(obj) )\n\t\tif ( obj[key] === null )\n\t\t\tjsx = [ jsx, (<span className='d-block'>{key} >>> <i>null</i></span>) ];\n\t\telse if ( typeof obj[key] === 'object' )\n\t\t\tjsx = [ jsx, (<span className='d-block'>{key} >>> <i>Object</i></span>) ];\n\t\telse jsx = [ jsx, (<div  className='d-block'> { key  } >> <b>{ obj[key] }</b></div>) ]\n\treturn jsx;\n}","import React, { useState } from 'react'\nimport NextTurnButton from './NextTurnButton'\nimport { renderObject } from \"../helpers\";\n\nfunction TopNav({ cards, currentPlayer, hand, players, gameAPI, gameOptions }) {\n\n  const [open, updateOpen] = useState(false);\n\n  // returns player object\n  const getCurrentPlayer = () => players[currentPlayer]? players[currentPlayer] : {} ;\n\n  \n  return (\n    <div className={'TopNav container ' + (open ? 'open' : 'closed')}>\n      <div className='row text-center'>\n        <small className={ 'card col-4' }> { getCurrentPlayer().name } ({currentPlayer})</small>\n        <small className={ 'card col-4 bg-' + (hand.canMoveNext.can ? 'success' : 'danger ') } > can pass turn </small>\n        <small className={ 'card col-4 bg-' + (hand.canMoveNext.must ? 'success' : 'danger ') } > turn is finished </small>\n      </div>\n        \n        \n      <button className={'btn btn-primary btn-sm'} onClick={gameAPI.initDemoGame}>Load cards</button>\n      <button className={'btn btn-secondary btn-sm ' + ( cards.length? '' : 'd-none' ) } onClick={ () => gameAPI.startGame() }>Start game</button>\n    </div>\n  );\n}\n\nexport default TopNav;\n","import React from 'react'\nimport '../css/Card.scss';\n\nfunction Card({ card, place, allowedToBuild, cardsAPI }) {\n\n  if (!card) {\n    return <p>No card!</p>\n  }\n\n  // build card on click, if we are on the place===player-private and it's buildable\n  const handleClick = (e) => {\n    e.preventDefault();\n\n    if (card.type === 'district' && place === 'player-private') {     \n      if (cardsAPI)\n      cardsAPI.buildCard(card.ID);\n    }\n  }\n\n  const isBuyable = allowedToBuild; \n  let classes = \"Card \";\n\n\n  classes += `Card--${ card.type } Card--color-${(card[\"type-of-district\"] || card[\"character-number\"] || \"default\" )}`;\n  classes += card.is_killed ? \" Card--killed\" : \"\";\n  classes += card.is_stolen ? \" Card--stolen\" : \"\";\n  classes +=  isBuyable? \" hover-border cursor-pointer Card--is-buyable\" : ( place === 'player-private' ) ? \" Card--no-buyable\" : \"\";\n  \n  return (\n    <div className={ classes } onClick={ isBuyable? handleClick : null } data-cardid={ card.ID }>\n      <div className={'badge Card__badge Card__badge--color-' +(card[\"type-of-district\"] || card[\"character-number\"]) }>\n          <span className='position-absolute'> {card[\"character-number\"]? card[\"character-number\"] : <React.Fragment>&nbsp;</React.Fragment> } </span>        \n      </div>\n      { card.is_killed? ( <img className='Card__icon img-fluid' src=\"/imgs/is-killed.png\" alt='killed'/> ) : null  }\n      { card.is_stolen? ( <img className='Card__icon img-fluid' src=\"/imgs/is-stolen.png\" alt='stolen'/> ) : null  }\n      <img className=\"Card__image mx-auto img-fluid\" src={card.image} alt={ card.description} />\n      <p className=\"Card__title\">\n        {card.name}\n        {\n          card.price? <span className=\"d-block\">$ {card.price} { card['extra-price']? `(+${card['extra-price']})` : '' }</span> : ''\n        }\n      </p>\n    </div>\n  );\n}\n\nexport default Card;\n","// This is called in CardsDeck.js, inside fn viewWrapperCharacter(). \n// Only used when the stage is a character call.\nimport React from 'react';\nimport '../css/ActionButton.scss';\n\nfunction ActionButton({  hand, setHand, currentPlayer, playersAPI, gameAPI, cardsAPI }) {\n\n  // Action to take Money or take cards\n  if (!hand) return\n  if ( null === currentPlayer) return null;\n  const { mustChooseCoinsOrCards } = gameAPI.getCurrentStageParams();\n\n  // if we are not in a call stage\n  const theCharacterCard = cardsAPI.getCalledCharacterCard();\n  if ( !theCharacterCard || theCharacterCard === {})\n    return null;\n  \n  // ---- End of VALIDATION ------\n\n  // when clicking on the selected action\n  const handleCoinsOrCardsAction = (action) => {\n\n    const clonedHand = Object.assign({}, hand);\n    \n    if (clonedHand.coinsOrCardsThisTurn) { // for some reason if I use 'hand' the value is not updated.\n      console.log(`action take ${action} is not allowed. You already performed your action (${clonedHand.coinsOrCardsThisTurn})`);\n      return;\n    }\n\n\n    // give 2 coins to the player\n    if ( action === 'money' ) {\n      playersAPI.giveMoneyToPlayer(2);\n      gameAPI.checkMoveToNextPlayerOrStage();\n    }\n    // give 2 cards to the player\n    if ( action === 'cards' ) {\n      console.log('Cards the player');\n      playersAPI.pickUpCard({ cardID: 'last-district-card', times: 2}); // this calls already to checkMoveToNextPlayerOrStage();\n    }\n\n\n    setHand( Object.assign(clonedHand, { coinsOrCardsThisTurn: action }) );\n    //->>>> trigger hand.coinsOrCardsThisTurn change\n  }\n\n  // --- End of the HANDLE CLICK --- \n\n\n  let msg = null;\n  \n  // Messages before the button, set up dynamically depending on actions\n  msg = [ msg, hand.messages.before_coins_or_cards_btn ];\n  // message about player action money/cards\n  if ( !mustChooseCoinsOrCards) {\n    // this means that this players is not allowed to take an action (ie, his called card is killed)\n    msg = [ msg, <h3 key='shutup'>No action allowed</h3> ];    \n  }\n \n  // Messages after the button, set up dynamically depending on actions\n  let msg_after = null;\n  msg_after = [ msg_after, hand.coinsOrCardsThisTurn ? hand.messages.after_coins_or_cards_action : hand.messages.after_coins_or_cards_btn ];\n\n  const btnClass = ( mustChooseCoinsOrCards && !hand.coinsOrCardsThisTurn) ? 'CardsDeck__actions--enabled btn-primary' : 'CardsDeck__actions--disabled btn-secondary';\n    \n  return (      \n    <div className=\"CardsDeck__actions\">\n      { msg } \n      { mustChooseCoinsOrCards? (\n        <React.Fragment>\n          { (!hand.coinsOrCardsThisTurn               \n                && !hand.messages.before_coins_or_cards_btn\n             )? <p key='k-4423'>Choose between taking 2 coins or 2 cards</p> : null }\n\n          <button className={ 'btn ' + btnClass + (hand.coinsOrCardsThisTurn === 'money'? ' btn-info ': '') } \n                  onClick={ () => handleCoinsOrCardsAction('money') } >\n            Money\n          </button>\n          <button className={ 'btn  ' + btnClass + (hand.coinsOrCardsThisTurn === 'cards'? ' btn-info ': '') }\n                  onClick={ () => handleCoinsOrCardsAction('cards') } >\n            Cards\n          </button>\n        </React.Fragment>\n      ) : null }\n      { msg_after }\n    </div>\n  );    \n\n}\n\nexport default ActionButton;","import React, { useState } from 'react'\nimport Card from './Card'\nimport ActionButton from './ActionButton'\nimport NextTurnButton from './NextTurnButton'\nimport '../css/CardsDeck.scss';\nimport { isEmpty, logg } from \"../helpers\";\n\nfunction CardsDeck({ cards, characterCards, setCharacterCards, districtCards, setDistrictCards, players, setPlayers, hand, setHand, currentPlayer, playersAPI, gameAPI, cardsAPI }) {\n              \n  // CONTROLLER ++++++++++++++++++++++++++++++++++++++++\n\n  // the turn of discard 1 card from the character deck. This could be in the original cardsAPI definition\n  cardsAPI.removeRandomCharacterCard = () => {\n    if (!characterCards.length) return null;\n    let clonedCardsArray = [ ...characterCards ];\n    clonedCardsArray.splice(Math.floor(Math.random() * clonedCardsArray.length), 1);\n    setCharacterCards(clonedCardsArray);\n\n    // @MAYBECHANGE: I think we could avid this and simply move to nextStage here.\n    const clonedHand = Object.assign({}, hand);\n    setHand(Object.assign(clonedHand, { pickedCardsThisPlayerTurn : (hand.pickedCardsThisPlayerTurn + 1)}) ); \n    //->>>> trigger hand.pickedCardsThisPlayerTurn change\n  }\n\n\n  // VIEWS:\n\n  // 2) View on stage 'district-selection'\n  const viewDistrictSelectionDeck = () => {\n    if (hand.stage !== 'district-selection') return null;\n   \n    const clickHandle = () => {\n      playersAPI.pickUpCard({ cardID: 'last-district-card', times: 4 } );\n    }\n\n    return (\n      <React.Fragment>\n        <p>Hi {players[currentPlayer].name}, click on the card to grab your initial {gameAPI.getCurrentStageParams().minCardsToPickup} district cards</p>\n        <ul className='row list-unstyled'>\n          <li className='offset-3 col-6 pt-4' onClick={ clickHandle }>\n            <img className=\"m-auto img-fluid\" src=\"/imgs/back.jpeg\" alt=\"Click the card to pick it up!\" />\n          </li>\n        </ul>\n      </React.Fragment>\n    );\n  }\n\n  const viewDiscardCharacterDeck = () => {\n    if (hand.stage !== 'discard-character') return <hr />;\n    return (\n      <div>\n        <p>Click to remove one random card from the characters' deck</p>\n        <ul class='d-inline-flex p-0 justify-content-center flex-wrap' onClick={ () => { cardsAPI.removeRandomCharacterCard() } }>\n        {\n          cards.filter( c => c.type === 'character' ).map( card => {\n            return (<li class='Card small-card cursor-pointer hover-border'><img className=\"small-card img-fluid\" src=\"/imgs/back.jpeg\"  alt=\"\" /></li>);\n          } )\n        }\n        </ul>        \n      </div>\n    );\n  }\n\n  // 2) View on stage 'character-selection'\n  const viewCharacterSelectionDeck = () => {\n    if (!hand.stage || hand.stage.indexOf('character-selection') < 0) return <hr />;\n    const characterRound = parseInt(hand.stage.slice(hand.stage.lastIndexOf('-') + 1)); // grabs 2 from 'character-selection-2' \n    return (\n      <React.Fragment>\n      <p>Select your {characterRound===1?'first':'second'} character, {typeof currentPlayer === 'number'? players[currentPlayer].name : ''}</p>\n      <ul className='row small-cards px-0'>\n        {characterCards.map(card => {\n          return (\n            <li key={card.ID} className='col-3 my-2 list-unstyled' onClick={ (e) => playersAPI.pickUpCard({ cardID: card.ID } ) }>\n              <Card card={card} />\n            </li>\n          );\n        })}\n      </ul>\n      </React.Fragment>\n    );\n\n  }\n\n  const viewWrapperCharacter = () => {    \n\n    if (!hand) return;\n    if (!hand.stage) return;\n    const theCard = cardsAPI.getCalledCharacterCard();\n    if ( !theCard || isEmpty(theCard) ) return;\n    \n    // find card for the current character\n    if (!theCard) return <p>No card found for the character</p>\n \n    // init params for this hand:\n    const { characterAct, mustChooseCoinsOrCards, allowedToBuild } = gameAPI.getCurrentStageParams();\n\n    // init the jxs for the right column\n    let special_character_action_jsx = null;\n\n    if ( null === currentPlayer) { // this was set when (!playersAPI.getPlayerWhoOwnsCharacterCard(characterNumber))\n      special_character_action_jsx = (<p key='p-smt'>\n                Nobody has the character {theCard.name} <br/>\n      </p>);\n    }\n    else {\n      // The character act for the magician can happen before the coinOrCards decision\n      if ( characterAct && hand.characterActThisTurn === false && theCard[\"character-number\"] === 3)\n        special_character_action_jsx = partialViewCharacter_3();\n\n      // Normally, The character act sohuld happen after the Player action is taken\n      if (hand && hand.coinsOrCardsThisTurn)\n        // could check to write a msg of characted already acted\n        if ( characterAct && hand.characterActThisTurn === false ) \n        switch (theCard[\"character-number\"]) {\n          case 1:\n          case 2:\n            special_character_action_jsx = partialViewCharacter_1_and_2(theCard[\"character-number\"]);\n            break;    \n          case 3:\n            break;\n          case 4:\n            special_character_action_jsx = partialViewCharacter_4(); break;\n          case 5:\n            special_character_action_jsx = partialViewCharacter_5(); break;\n          case 6:\n            special_character_action_jsx = partialViewCharacter_6(); break;\n          case 7:\n            special_character_action_jsx = partialViewCharacter_7(); break;\n          case 8:\n            special_character_action_jsx = partialViewCharacter_8(); break;\n          default: break;\n        }\n    }\n\n    if ( typeof currentPlayer === 'number' ) { \n      // show text of after chaacter acted. This is set during the action of the char.\n      if ( hand.characterActThisTurn ) {\n        if (hand.messages.after_character_acts)  {\n          special_character_action_jsx = [ special_character_action_jsx, hand.messages.after_character_acts ];\n        }\n        // default msg after character did his action\n        if (mustChooseCoinsOrCards && !hand.coinsOrCardsThisTurn)\n          special_character_action_jsx = [ special_character_action_jsx, (<p key='shutup1'>You can take your action - grab money or district cards - </p>) ];\n        if ( hand.canMoveNext.can )\n          special_character_action_jsx = [ special_character_action_jsx, (<p key='shutup2'>You can pass turn to the next character.</p>) ];\n        if ( playersAPI.playerCanBuild(currentPlayer) )\n      special_character_action_jsx = [ special_character_action_jsx, (<p key='shutup3'>Or you can build {allowedToBuild} district{allowedToBuild>1? 's' : ''}.</p>) ];  \n      }\n    }\n\n    // add description of the card before the inteaction act from the character.\n            \n    return (\n      <div className='container'>\n        <div className='row'>\n          <div className='col-4' key='2356'>\n            <Card card={ theCard } />\n\n           { ( characterAct ) ? ( <p key='sthn-more'>{theCard.description}</p> ) : null }\n    \n          </div>\n          <div className='col-8' key='2793'>\n            \n            <ActionButton hand={hand} setHand={setHand} currentPlayer={currentPlayer} playersAPI={playersAPI} gameAPI={gameAPI} cardsAPI={cardsAPI} />\n\n            { special_character_action_jsx }\n\n            <NextTurnButton hand={hand} gameAPI={gameAPI} />\n\n\n          </div>\n        </div>\n      </div>\n\n    )\n  }\n\n  // Assassin and Thief CALL. Show the card (the assass or thief) and the list of characters to select one.\n  const partialViewCharacter_1_and_2 = (charNum) => {\n    // the list of characters cards to show.\n\n    // characters you can't steal from: the assassin or the assassin target (is_killed).\n    let eC = []; // this var could be called \"extra characters you can't touch\", but I call it ec.\n    if (charNum === 2) {\n      \n      const theKilledCardIndex = cards.findIndex( c => c.is_killed );\n      eC = [ cardsAPI.getCardIndexByCharacterNumber(1) ].concat( (theKilledCardIndex >= 0) ? [theKilledCardIndex] : [] ); // index of cards\n    }\n\n    // characterss except the assasin and except the other character that the player has\n    const characterCards = [...cards ].filter(card => \n        card.type && card.type === 'character' \n        && card['character-number'] !== charNum \n        && !players[currentPlayer].characterCards.includes( cardsAPI.getCardIndexByID(card.ID) )  // don't show you chanracters. dont kill you self!\n        && !eC.includes( cardsAPI.getCardIndexByID(card.ID) )  // don't show the excluded characters, which are the killer and eny killed characted.\n    );\n\n    const clickHandle = (selected_character_number) => {\n      switch (charNum) {\n        case 1: cardsAPI.killCharacter(selected_character_number);\n          break;\n        case 2: cardsAPI.stealCharacter(selected_character_number);\n          break;\n        default: break;\n      }      \n    }\n\n    return (\n      // show all character cards except the assassin and you own char\n      <React.Fragment>        \n        <p>Select the character that you want to { charNum === 1 ? 'kill' : 'steal from' } </p>\n        <ul className=\"list-unstyled row CardsDeck__character-pickup\">\n        { \n          characterCards.map( (card, i) => {\n            return  ( <li key={'charno-'+i} className=\"col-4 px-0 pb-3\" onClick={ (e) => clickHandle(card['character-number']) }>\n                        <Card key={card.ID} card={card} />\n                      </li> );                \n          } ) }\n        </ul>        \n        { // extra info about the characters you cant steal from\n        (charNum === 2)? <small>          \n            You can't steal from {                 \n                eC.map( (cardIndex, i) => \n                  (((i+1) === eC.length) && (eC.length > 1) ? ' or ' : (i?', ':'') ) \n                  + cards[cardIndex].name )\n                }  </small> : null }\n      </React.Fragment>\n    );\n  }\n\n  // 3: the magician: shows all players and you have to select 1 of them or the deck.\n  const partialViewCharacter_3 = () => {\n    \n    // put current cards on the beggining of districtCards deck, and take same amount from top.    \n    const handleDiscardCards = () => {\n      let tempDistrictCards = [...districtCards];\n      let listCurrentPlayerCard = players[currentPlayer].districtCards.map( cardIndex => ( cards[cardIndex] ) ).filter( card => !card.is_built );\n      tempDistrictCards = listCurrentPlayerCard.concat(tempDistrictCards); // this is the new districtCards deck\n      setDistrictCards(tempDistrictCards); // put the cards on the beginning\n      \n      // now pick same amount of cards.\n      const numberOfCards = listCurrentPlayerCard.length;      \n      let updatePlayers = [...players];\n      // remove the private cards from player. This is a little long but basically inits the district cards of the player to the built ones (so basically has removed the ones not built)\n      updatePlayers[currentPlayer].districtCards = updatePlayers[currentPlayer].districtCards.filter(cc => !listCurrentPlayerCard.map( ca => cardsAPI.getCardIndexByID(ca.ID) ).includes(cc)); // discard the cards\n      \n      // get the last top cards from district deck\n      for (let i = 0; i < numberOfCards; i++) {\n        let lastCard = tempDistrictCards.pop();\n        updatePlayers[currentPlayer].districtCards.push(cardsAPI.getCardIndexByID(lastCard.ID));\n      }\n      setPlayers(updatePlayers);\n\n      logg('@ACTION OF POWER for character 3: Magician - replace cards with the deck');\n      setHand(Object.assign({...hand}, { characterActThisTurn: 'replaced-cards' }));\n      gameAPI.setMessage('after_character_acts', (<h3>Your cards have been replaced by cards on the deck</h3>));\n    }\n    // now the view\n    return (\n      <React.Fragment>\n        <div className=\"col-12 my-4\">You can change the cards in your hand. Select, if you want, how you want to discard your hand</div>\n        <div className=\"d-flex-row flex-wrap\">\n          <div className=\"col-sm\">\n            {\n            (hand.canMoveNext.can) ?  \n              <button class='btn btn-danger mb-4' onClick={gameAPI.moveToNextPlayerOrStage} >Don't discard and move to next player</button> \n              : \n              null\n            }\n            <button className=\"btn btn-info w-100\" onClick={handleDiscardCards}>\n              Discard on Deck\n              <ul className=\"d-inline-flex list-unstyled extra-small-cards\">\n                {  // show back of cards for the non built ones\n                players[currentPlayer].districtCards.filter( ci => !cards[ci].is_built ).map( ci => {\n                  return (<li key={'dd' + ci} ><img className=\"small-card img-fluid p-1\" src=\"/imgs/back.jpeg\"  alt=\"\" /> </li>);\n                } )  }\n              </ul>\n            </button>\n          </div>\n          <hr className='w-100'/>\n          { players.map( (player, playerIndex) => {\n            \n            const privateCards = player.districtCards.filter( cardIndex => !cards[cardIndex].is_built );\n            return (\n              (playerIndex === currentPlayer)? null\n              :\n              ( \n                <div key={'k'+playerIndex} className=\"col-sm\" onClick={ () => playersAPI.swapDistrictCardsBetweenPlayers( null, playerIndex) } >\n                  <button className={ 'mb-3 btn ' + (privateCards.length? ' btn-primary ' : '') }>\n                    <p className=\"mb-0\"> \n                      Exchange cards with <b>{player.name}</b> \n                      <small className='d-block'>{privateCards.length} cards</small>\n                    </p>\n                    { \n                      ( !privateCards.length) ? \n                          ( <p>No cards</p> ) \n                          :\n                          ( \n                            <ul className=\"d-inline-flex list-unstyled\">\n                            { privateCards.map( (c,i) => <li key={'dd' + i} ><img className=\"small-card img-fluid p-1\" src=\"/imgs/back.jpeg\"  alt=\"\" /> </li> )  } \n                            </ul> \n                          )\n                    }\n                  </button>\n                </div>\n              )\n            );\n          }) }\n        </div>\n      </React.Fragment>\n    );\n  }\n\n  // 4: the king\n  const partialViewCharacter_4 = () => {    \n    return (\n      <div>\n        <p> You get the crown. You will start next turn. </p>\n      </div>\n    );\n  }\n\n  const partialViewCharacter_5 = () => {\n    return (\n      <div>        \n        You are inmune to any attack from the Warlord\n      </div>\n    );\n  }\n\n  // the merchant (Mr Burns)\n  const partialViewCharacter_6 = () => {\n    // the money is given in lifecycle hand.coinsOrCardsThisTurn update.\n    if (gameAPI.getCurrentStageParams().mustChooseCoinsOrCards) {\n     if (!hand.coinsOrCardsThisTurn) \n        return <p>You will receive $ 1 after taking your action </p>    \n      // return <div> There you go!. You have $ 1 more. </div> we do it tiwh the message param\n    }\n    return null;\n  }\n\n  // the architect - receives 2 cards and can build 3 cards\n  const partialViewCharacter_7 = () => {\n    if (gameAPI.getCurrentStageParams().mustChooseCoinsOrCards) {\n      if (!hand.coinsOrCardsThisTurn)      \n        return ( <React.Fragment>\n            <p>You will receive 2 cards after taking your action </p>    \n            <p>You can build up to ${gameAPI.getCurrentStageParams().allowedToBuild} cards this turn. </p>    \n            </React.Fragment> \n        );\n      return <div> There you go!. You took { hand.pickedCardsThisPlayerTurn } cards in your hand. Happy building!</div>\n    }\n    return false;\n  }\n\n  // Bart, can destroy one district card built\n  const partialViewCharacter_8 = () => {\n    // destroying the card\n    const handleCardClick = (card) => {\n      if (playersAPI.destroyBuiltCardByWarlord(card)) {\n        setHand(Object.assign({...hand}, { characterActThisTurn: 'destroy-card' }));\n        logg('@ACTION OF POWER for character 8: Warlord - destroys a card');\n      }\n    }\n\n    logg('@ACTION OF POWER for character 5 - The player with this card can not be destroyed');\n    const playersStoleable = players.filter( (plyr,indx) => (indx !== currentPlayer) && (!playersAPI.playerHasCharacter( indx, 5)) );\n    const { playerIndex: bishopPlayerIndex } = playersAPI.getPlayerWhoOwnsCharacterCard(5);\n    \n    return (\n      <div>        \n        <p>Select the district you want to destroy</p>\n        {\n          (bishopPlayerIndex !== currentPlayer && typeof bishopPlayerIndex === 'number' && bishopPlayerIndex >= 0)? (\n              <p>You can't attact <b>{players[bishopPlayerIndex].name }</b>, because he has the Bishop character.</p>\n          ) : null\n        }\n        { \n        playersStoleable.map(( player, playerIndex )=> {\n          const builtCards = player.districtCards\n                              .filter( cardIndex => cards[cardIndex].is_built )\n                              .map( ( cardIndex, i ) => cards[cardIndex] );       \n          return ( \n            <div key={ ' player-to-destroy-' + playerIndex} >\n              <h3>{ player.name } <small> {builtCards.length} cards </small></h3>            \n              { !builtCards.length ? (<p>No cards to destroy</p>) : (\n                <ul className='list-unstyled'>\n                { builtCards.map( card => {\n                  const destroyable = (card.price - 1) <= player.money;\n                  return (\n                    <li className={ 'small-card col-sm ' + (destroyable? 'destroyable' : 'undestroyable') }\n                        onClick={ () => handleCardClick(card) }\n                        key={ 'destroy-card-' + card.ID }\n                    >\n                      <Card card={card} />\n                    </li>\n                    ) \n                  }) \n                }\n                </ul>\n              ) }\n            </div>\n          )\n        })\n        }\n      </div>\n    );\n  }\n\n\n  return (\n    <div className=\"CardsDeck text-center\">\n      {viewDistrictSelectionDeck()}\n      {viewDiscardCharacterDeck()}\n      {viewCharacterSelectionDeck()}\n      {viewWrapperCharacter()}      \n    </div>\n  );\n}\n\nexport default CardsDeck;\n","import React, { useState } from 'react';\nimport Card from './Card'\n\nimport '../css/Player.scss';\n\n// @player: { name: 'Peter', characterCards: [ ... ], money: 5 .. }\nfunction Player({ player, index, playersAPI, crownPlayer, cards, setCards, cardsAPI }) {\n\n  return ( \n          <React.Fragment>\n            <div className='row'>\n              <div className='col-6'>\n                <h3 className=\"d-block\">{player.name}</h3>              \n              </div>\n              <div className='col-3'>\n                { (crownPlayer === index )? (<img className='Card__icon img-fluid h-100' src=\"/imgs/crown.png\" height='50' alt='crown'/> ) : null }\n              </div>\n              <div className='col-3'>\n                $ {player.money}\n              </div>\n            </div>\n\n            <div className='row'>            \n              <div className='col-2 extra-small-cards'>                \n                { player.characterCards.map( ( cardIndex, i ) => {\n                  const card = cards[cardIndex];\n                  return (\n                    <Card card={card} key={i} place={'character-private'} />\n                    )\n                  }) }\n              </div>\n              <div className='col-10'>              \n                <div className='row extra-small-cards'>                  \n                  { player.districtCards.filter( cardIndex => !cards[cardIndex].is_built )\n                        .map( ( cardIndex, i ) => {\n                            const dCard = cards[cardIndex];\n                            // TODO: make clicable if the currentPlayer has money to buy it!                            \n                            return (\n                              <Card key={'cc-'+cardIndex} place={'player-private'}  card={dCard} allowedToBuild={playersAPI.playerCanBuild(index, cardIndex)} cardsAPI={cardsAPI} />\n                              )\n                    }) }\n                </div>\n                <hr />\n                <div className='row extra-small-cards'>\n                { player.districtCards.filter( cardIndex => cards[cardIndex].is_built ).map( ( cardIndex, i ) => {\n                    const card = cards[cardIndex];\n                    return (\n                      <Card card={card} key={i} place={'player-built'} player={player} cards={cards} setCards={setCards} />\n                      )\n                    }) }\n                </div>\n              \n              </div>\n            </div>\n          </React.Fragment>\n         );\n}\n       \nexport default Player;\n","import React from 'react'\nimport Player from './Player'\n\n// @players: array of player { name: 'Peter', cards: [ ... ], money: 5 }\nfunction Players({ players, currentPlayer, crownPlayer, cards, setCards, cardsAPI, playersAPI }) {\n  \n  return (\n    <div className=\"Players\">\n      {\n        players.map( (player, index) => {\n         const isCurrentPlayer = index === currentPlayer;\n         const wrapperClass = \"Players__player-wrapper \" + (isCurrentPlayer? 'Players__player-wrapper--active' : '');\n         return (\n            <div key={'Player'+index} className={wrapperClass}>\n              <Player player={player} index={index} playersAPI={playersAPI} crownPlayer={crownPlayer} cards={cards} setCards={setCards} cardsAPI={cardsAPI} />\n            </div >\n          )\n        }\n        )\n      }\n    </div >\n  );\n}\n\nexport default Players;\n","import React, { useState } from 'react';\nimport Players from './Players';\n\nfunction Footer({ players, crownPlayer, currentPlayer, cards, setCards, cardsAPI }) {\n  return (\n    <footer className=\"Footer\">\n      This is the footer\n    </footer>\n  );\n}\n\nexport default Footer;\n","import React from 'react'\nimport { renderObject } from \"../helpers\";\n// import '../css/Debug.scss';\n\nfunction Debug({ gameOptions, hand, gameAPI, stages }) {\n\n  return (\n    <React.Fragment>\n    <h5 key='874'>Hand situation</h5>\n    { gameOptions.dev ? renderObject(hand) : null }\n    <hr/>        \n    <h5>Stage original settings</h5>\n    <div className=\"opacity-50\">\n      { gameOptions.dev ? renderObject(hand.stage? stages[hand.stage] : null) : null }\n    </div>\n    <hr/>\n    <h5 key='9843'>Stage actual settings</h5>\n    <div key='fds732'>\n      { gameOptions.dev ? renderObject(gameAPI.getCurrentStageParams()) : null }\n    </div>\n    </React.Fragment>\n\n  );\n}\n\nexport default Debug;\n","/*TODO:\n\n  Al construir, evitar q se puedan construir dos cartas iguales. (actualizar allow to build, buildable card)\n  BUG: turno lenny & card. Escoger cartas y no dinero. A acabar la accion se ejecuta la Character Act, q es tomar 2 cartas mas. Pero la turn param pickedCardsThisPlayerTurn se queda en 2 y no 4.\n*/\nimport React, { useState, useEffect, useRef } from 'react'\nimport TopNav from './TopNav';\nimport CardsDeck from './CardsDeck';\nimport Card from './Card';\nimport Footer from './Footer';\nimport Players from './Players';\nimport Debug from './Debug';\nimport '../css/App.scss';\nimport { shuffle, unique, isEmpty, logg, logfn, renderObject } from \"../helpers\";\n\n\nfunction App() {\n\n  // M O D E L +++++++++++++++++++++++++++++++++++++++\n  const [cards, setCards] = useState([]); // [ {cardOjb}, {cardObj} ... ]\n  const [characterCards, setCharacterCards] = useState([]); // [ {cardOjb}, {cardObj} ... ] (it would have been better a list of index)\n  const [districtCards, setDistrictCards] = useState([]);\n  const [players, setPlayers] = useState([]); // [ {playerObj}, {playerObj} ... ]\n  const [crownPlayer, setCrownPlayer] = useState(null); // set to the player index\n  const [hand, setHand] = useState({ number: null, \n                                     // stage: THIS is IMPORTANT info in the game. Tells in what stage we are. Goes together with 'stages' var.\n                                     stage: null,\n                                     // THIS STATE CHANGE trigger the Events of the game and allow to change the stage.\n                                     pickedCardsThisPlayerTurn: 0, // EVENT: pick up a card \n                                     builtCardsThisPlayerTurn: 0, // EVENT: build a district\n                                     coinsOrCardsThisTurn: false, // if false, no action is allowed. (action means either take 2 coins or grab 2 district cards)\n                                     characterActThisTurn: null, // kill, thief ... Only for character call turn\n                                     canMoveNext: {}, // {can: bool, must: bool} tells if the current turn can be finished (false if there sre still mandatory actions to be taken in the turn)\n                                     districtsBuiltThisPlayerCharacter: 0, // only for the call-character stages. It's the number of cards for the current character, and built by the player who owns the current character.\n                                     stageParamsThisTurn: {}, // we initialize this from 'stages' var, every time hand.stage changes.\n                                     messages: {\n                                       before_coins_or_cards_btn: null,\n                                       after_coins_or_cards_btn: null,\n                                       after_coins_or_cards_action: null,\n                                       after_character_acts: null,\n                                     }\n                                     }); // starts in 0. Every complete hand increments\n  const [currentPlayer, setCurrentPlayer] = useState(null); // index of player from the 'players' array. If null the hand didnt start\n  const [temporaryMessage, setTemporaryMessage] = useState(null);\n  const [gameOptions, setgameOptions] = useState({\n    dev: true\n  });\n\n  const stages = {\n                  'district-selection' :    { loopPlayers: true, maxCardsToPickup: 4, minCardsToPickup: 4},\n                  'discard-character':      {maxCardsToPickup: 1, minCardsToPickup: 1},\n                  'character-selection-1' : { loopPlayers: true, maxCardsToPickup: 1, minCardsToPickup: 1},\n                  'character-selection-2' : { loopPlayers: true, maxCardsToPickup: 1, minCardsToPickup: 1}, \n                  'call-character-1' : { mustChooseCoinsOrCards: true, characterAct: 'mandatory', maxCardsToPickup: 2, allowedToBuild: 1 },\n                  'call-character-2' : { mustChooseCoinsOrCards: true, characterAct: 'mandatory', allowedToBuild: 1 },\n                  'call-character-3' : { mustChooseCoinsOrCards: true, characterAct: 'optional', allowedToBuild: 1 },\n                  'call-character-4' : { mustChooseCoinsOrCards: true, characterAct: 'automatic', allowedToBuild: 1 },\n                  'call-character-5' : { mustChooseCoinsOrCards: true, characterAct: 'none', allowedToBuild: 1 },\n                  'call-character-6' : { mustChooseCoinsOrCards: true, characterAct: 'automatic', allowedToBuild: 1 },\n                  'call-character-7' : { mustChooseCoinsOrCards: true, characterAct: 'automatic', allowedToBuild: 3 }, // the architect can build up to 3 cards\n                  'call-character-8' : { mustChooseCoinsOrCards: true, characterAct: 'optional', allowedToBuild: 1 },\n  };\n  \n  const clonedHand = { ...hand }; // we define this globally, so if two setState happen in the same refresh, the second takes the updated value from the first.\n\n\n  // Helper - use it with a state param. ie const prev = usePrevious(cards)\n  const usePrevious = value => {\n    const ref = useRef();\n    useEffect(() => {\n      ref.current = value;\n    });\n    return ref.current;\n  };\n\n  // C O N T R O L L E R ++++++++++++++++++++++++++++++++++++++++\n\n\n                /*        G A M E   A.P.I\n                _______________          |*\\_/*|________\n                |  ___________  |        ||_/-\\_|______  |\n                | |           | |        | |           | |\n                | |   0   0   | |        | |   0   0   | |\n                | |     -     | |        | |     -     | |\n                | |   \\___/   | |        | |   \\___/   | |\n                | |___     ___| |        | |___________| |\n                |_____|\\_/|_____|        |_______________|\n                  _|__|/ \\|_|_.............._|________|_\n                / ********** \\            / ********** \\\n              /  ************  \\        /  ************  \\\n */\n  const gameAPI = {\n    initDemoGame: () => {\n      cardsAPI.loadCards();\n      gameAPI.initPlayers(['Giuseppe', 'Guillauseppe', 'Phillipseppe']);\n    },\n    \n    // @MODEL:PLAYERS - INIT\n    // @players: array with names of the players , ie [ 'Peter', 'Mary', 'Ignatius' ]\n    // inits the state players.\n    initPlayers: (players) => {\n      logfn( 'initPlayers', [...arguments ]);    \n      const allPlayers = players.map(name => ({\n        name,\n        money: 0,\n        characterCards: [], // array of indexes in 'cards' array\n        districtCards: [],\n        pickedCardsInThisTurn: 0\n      }) );\n      // optional: shuffle the array\n      setPlayers(allPlayers);\n    },\n      \n    // @MODEL:APP game\n    startGame: () => {\n      logfn( 'startGame', [...arguments ]);\n\n      if (!cards.length) {\n        alert('load the cards first');\n        return;\n      }\n      // TODO: validation. We can start a new hand only when the game didnt start or when the last player finished his turn\n\n      // When we change the stage we trigger the useEffect to shuffle the decks\n      setCurrentPlayer(0); //->>> currentPlayer change trigger\n      const keys = Object.keys(stages);\n      setHand(Object.assign( clonedHand, { stage: keys[0] })); // set to initial stage\n      setCrownPlayer(0);  \n      cardsAPI.initDistrictOrCharacterDeck('district', true);\n    },\n\n    resetHandParams: () => {\n      logfn( 'resetHandParams', [...arguments ]);  \n\n      clonedHand.stageParamsThisTurn = (clonedHand && clonedHand.stage)? stages[clonedHand.stage] : {};      \n      clonedHand.pickedCardsThisPlayerTurn= 0; \n      clonedHand.builtCardsThisPlayerTurn= 0;      \n      clonedHand.coinsOrCardsThisTurn = false;\n      clonedHand.characterActThisTurn = false;\n      clonedHand.canMoveNext= {}; // when it will be possible it will become { can: true, must: true/false }\n      clonedHand.districtsBuiltThisPlayerCharacter= 0;\n      clonedHand.messages= {};\n\n      setHand(clonedHand); // doenst trigger event\n    },\n\n    // @MODEL:APP game - changes the stage to the next.\n    moveToNextStage: () => {\n      logfn( 'moveToNextStage from', hand.stage);\n      let nextStage = null;\n      const keys = Object.keys(stages);      \n      if (hand.stage)\n        keys.forEach( ( stageName, i) => {\n          if ( stageName === hand.stage) { // found current stage\n              // assign the next stage\n              if (i === (keys.length - 1)) {\n                nextStage = 'discard-character';  // when finished the stages (call-character-8) we start over\n              } else {              \n                nextStage = keys[i + 1];  // NEXT stage\n              }\n            }\n          });\n      else {\n        nextStage = keys[0]; \n      }\n      setHand(Object.assign(clonedHand, {stage: nextStage})); \n      //->>>> hand.stage change triggers\n    },\n\n    setMessage: ( key, jsx ) => {\n      if (!clonedHand.messages) return;\n      if (clonedHand.messages[key]) clonedHand.messages[key] = null;\n      clonedHand.messages[key] = [clonedHand.messages[key], jsx];\n      setHand(clonedHand);\n    },\n\n    // @MODEL:APP game - when the turn is finished and we move fw (this fn knows if we move to next player or next stage)\n    moveToNextPlayerOrStage: () => {\n        const { loopPlayers } = gameAPI.getCurrentStageParams();\n\n        let moveStage = !loopPlayers;\n        logfn( 'moveToNextPlayerOrStage', `moveStage ${moveStage}, loopPlayers ${loopPlayers}` );\n        \n        if (loopPlayers) {\n          let nextPlayer = currentPlayer + 1;\n          if (nextPlayer === players.length) {\n            logg('Turned around all players. Next stage, please! ');\n            nextPlayer = null;\n            moveStage = true;\n          } \n          setCurrentPlayer(nextPlayer); //->>>> currentPlayer change trigger (resets hand params)\n        }\n\n        if (moveStage) {\n          gameAPI.moveToNextStage(); // triggers hand.stage\n        }\n\n    },\n    \n    // @MODEL:APP game - sees if the conditions of the game (in hand) are fulfilled with the requirements of the stage.\n    // we check it when we pick up a card, we build a district, take an action(money or card), and character acts.\n    checkMoveToNextPlayerOrStage: ( only_return_true_or_false = false ) => {\n\n      if (! hand.stage ) return false;\n      logfn( 'checkMoveToNextPlayerOrStage', `force action ${!only_return_true_or_false}` );\n\n      let canMove = true; // init. Will tell if the turn can finish or not (allowed to pass turn)\n      let shouldMove = false; // init. Will tell if the turn is finished completly so we force moving (for the case when the user can build and has to decide)\n      const {minCardsToPickup, mustChooseCoinsOrCards, characterAct } = gameAPI.getCurrentStageParams(); // object\n\n      // situation: character X (ie the assasin) is called and no player has the card.\n      // if (characterAct && (currentPlayer === null)) {\n      //   setHand(Object.assign( clonedHand, { canMoveNext: { can: true, must: true } } ));\n      //   return { allowedToMove: true, forcedToMove: true };\n      // }\n\n      // we check options that makes us decide that the player can not move to the next step yet\n      canMove = canMove && !(minCardsToPickup &&  clonedHand.pickedCardsThisPlayerTurn < minCardsToPickup);\n      canMove = canMove && !( mustChooseCoinsOrCards && !clonedHand.coinsOrCardsThisTurn ); // it means that action was not taken yet and it should.\n      canMove = canMove && !( (characterAct === 'mandatory' || characterAct === 'automatic') && ( !clonedHand.characterActThisTurn ) );\n      \n      // has the possibility of building?\n      // the reason that can hold the player from passing turn is that he can build.\n      if (canMove && ( !playersAPI.playerCanBuild() ) ) {\n        shouldMove = true;\n      }\n\n      // only informative option\n      if (only_return_true_or_false) {        \n        setHand(Object.assign( clonedHand, { canMoveNext: { can: canMove, must: shouldMove } } ));\n        return { allowedToMove: canMove, forcedToMove: shouldMove };\n      }\n\n      // normally this is the action. AT THE MOMENT THIS NEVER EXECTURES\n      if (shouldMove) {\n          gameAPI.moveToNextPlayerOrStage();        \n      }\n    },\n\n    // MODEL:APP game\n    getCurrentStageParams: () => {\n      if (clonedHand && clonedHand.stageParamsThisTurn)\n        return clonedHand.stageParamsThisTurn;\n      return {};\n    },\n\n    // @MODEL:APP game.\n    setUpCharacterSettings: (characterNumber) => {\n      logfn( 'setUpCharacterSettings', characterNumber);  \n      const { playerIndex, card } = playersAPI.getPlayerWhoOwnsCharacterCard(characterNumber);\n\n      setCurrentPlayer(playerIndex);\n\n      // @MAYBECHANGE: any action related to characters set in currentPlayer UPDATE could come here for uniformity.\n      \n      // if current character is killed there is no action he can make.\n      if (card.is_killed || playerIndex === null) {          \n        clonedHand.stageParamsThisTurn.mustChooseCoinsOrCards = false;\n        clonedHand.stageParamsThisTurn.characterAct = false;\n        clonedHand.stageParamsThisTurn.maxCardsToPickup = 0;\n        clonedHand.stageParamsThisTurn.allowedToBuild = 0;\n        gameAPI.setMessage('before_coins_or_cards_btn', card.is_killed? (<p>You are DEAD!</p>) : (<p>Nooo one</p>));\n        gameAPI.checkMoveToNextPlayerOrStage( true );\n        setHand(clonedHand);\n        return;          \n      }\n\n      // We call the card The King and move current Player to the payer that will get the crown.\n      if (hand.stage === 'call-character-4') {        \n        const { playerIndex : kingPlayerIndex } = playersAPI.getPlayerWhoOwnsCharacterCard(4); // currentPlayer is still not defined. So we take the new crown Owner from this\n        setCrownPlayer(kingPlayerIndex);\n        logg('@ACTION OF POWER for character 4 - The King. Get the crown: '+players[kingPlayerIndex].name);\n        setHand( Object.assign( clonedHand, { characterActThisTurn: 'get-the-crown'} ) );\n        gameAPI.setMessage('before_coins_or_cards_btn', <p>You got the crown, as the king that you are</p>);\n        // TODOMESSAGE\n      }\n\n      // \n      if (card.is_stolen) {\n        // al money goes to the player with character 2.\n        const { playerIndex: characted2PlayerIndex } = playersAPI.getPlayerWhoOwnsCharacterCard(2);\n        const clonedPlayers = [ ...players ];\n        clonedPlayers[characted2PlayerIndex].money += clonedPlayers[playerIndex].money;\n        clonedPlayers[playerIndex].money = 0;\n        gameAPI.setMessage('before_coins_or_cards_btn', <p>You have been stolen by the Thief!, owned by <b>{ players[characted2PlayerIndex].name }</b></p>);        \n        setPlayers(clonedPlayers);\n      }\n\n      // 4 characters receive gold by the cards on his ditrict: charNum 4, 5, 6, 8.\n      // we take the district cards from this player that are built and belong to this character\n      if ([4,5,6,8].includes(card['character-number'])) {\n        playersAPI.payPlayerByDistrictCardsType(playerIndex, card['character-number']);\n      }\n    }\n  \n\n  } // end gameAPI\n\n  /*  C A R D S     A.P.I      starts\n                        \n                      \n                              \n                      \n                       \n                             \n                               \n                               \n                 \n          \n          \n                    \n                     \n                      */\n  \n    const cardsAPI = {\n    // @MODEL:CARDS - INIT\n    // grab the cards from json file and load them into \n    loadCards: async () => {\n      logfn( 'loadCards', [...arguments ]);\n      // Change this in the future if we want to load different cards from an API\n      const url = window.location.origin + '/cardsdemo.json';\n      // var json = require(url); //(with path)\n      console.log(url);\n      await fetch(url)\n        .then(response => response.json())\n        .then(json => {\n          console.log(json);\n          json.forEach(card => {\n            if (card[\"repeat-card\"]) {\n              // in the file, if the card has the field repeat-card, we clone that card that amount of times.\n              const repeatTimes = card[\"repeat-card\"];\n              delete card[\"repeat-card\"];\n              for ( let i =1; i < repeatTimes; i++) {\n                let newCard = Object.assign({}, card);\n                newCard.ID = card.ID + '.'+i; // new ID is '104.1' for example\n                json.push(newCard);\n              }\n            }\n          });\n          setCards([...json]);\n        });\n\n      // or whatever you want to do with the resulting object\n    },\n\n    // @MODEL:CARDS\n    getCardIndexByID: cardID => cards.findIndex( card => card.ID === cardID ),\n    getCardByID: cardID => cards[cardsAPI.getCardIndexByID(cardID)],\n    getCardIndexByCharacterNumber: characterNumber => cards.findIndex( card => (card['character-number'] && card['character-number'] === characterNumber) ),\n    getCardByCharacterNumber: characterNumber => cards[cardsAPI.getCardIndexByCharacterNumber(characterNumber)],\n    getCalledCharacterCard: () => {\n        if (!hand || !hand.stage) return {};\n        if (!hand.stage.includes('call-character-')) return {};\n        const characterNumber = parseInt(hand.stage.slice(hand.stage.lastIndexOf('-') + 1)); // grabs 3 from 'call-character-3' \n        return cardsAPI.getCardByCharacterNumber(characterNumber);\n    },\n\n\n    // @MODEL:CARDS - get, from the whole deck, only the 'typeOfCard' (character/district) cards and shuffle them. Ready to be taken by players\n    // @param typeOfCard: 'character' cards, 'district' cards or all?\n    // @param shuffleBool: do we shuffle the created deck?\n    initDistrictOrCharacterDeck: (typeOfCard = null, shuffleBool = false) => {\n      logfn( 'initDistrictOrCharacterDeck', typeOfCard );\n      // 1) get, from Cards, only the type \"character\" or \"disctrict\" cards in an array.\n      let deck = [...cards ];\n      console.log('cards character not shuffled:', cards);\n      if (typeOfCard) {\n      deck = deck.filter(card => card.type && card.type === typeOfCard);\n      }\n      \n      // 2) shuffle it (using helper fn)\n      if (shuffleBool)\n        deck = shuffle(deck);\n\n      // Update the state of the list of cards\n      console.log(`deck of ${typeOfCard} shuffled and initialized as `, deck); \n      if (typeOfCard === 'character') \n        setCharacterCards(deck);\n      else if (typeOfCard === 'district')\n        setDistrictCards(deck);\n\n      return deck; // just in case, but normally we wont need it\n    },\n\n    // @MODEL:CARDS - \n    buildCard: (cardID) => {\n      let all_cards = [...cards];\n      let all_players = [...players];\n      const cardIndex = cardsAPI.getCardIndexByID(cardID);\n      const { playerIndex } = playersAPI.getPlayerWhoOwnsDistrictCard(cardID);\n      logfn( 'buildCard', cards[cardIndex].name );\n      \n      // VALIDATION\n      if (!gameAPI.getCurrentStageParams().allowedToBuild) {\n        console.log('this stage is not for building');\n        return;\n      }\n      if (hand.builtCardsThisPlayerTurn >= gameAPI.getCurrentStageParams().allowedToBuild) {\n        console.log('you already built enough');\n        return;\n      }\n      if (playerIndex !== currentPlayer) {\n        console.log('You can\\'t buy cards if you are not the current player');\n        return;\n      }\n      if (players[playerIndex].money < cards[cardIndex].price) {\n        alert(`Sorry, this card costs $${cards[cardIndex].price} and you only have ${players[playerIndex].money}!`);\n        return null; // the player doesnt have money to build that card\n      }\n\n      // remove money form player!\n      all_players[playerIndex].money -= cards[cardIndex].price;\n      setPlayers(all_players);\n\n      if ( typeof cardIndex === 'number' ) {\n        all_cards[cardIndex].is_built = true;\n        setCards(all_cards);\n\n        setHand(Object.assign( clonedHand, { builtCardsThisPlayerTurn : clonedHand.builtCardsThisPlayerTurn + 1 }) ); \n        //->>>> we didnt define trigger State Event hand.builtCardsThisPlayerTurn\n        \n        gameAPI.checkMoveToNextPlayerOrStage(true);\n        \n      }\n    },\n\n    // @MODEL:CARDS - updates the given card as 'killed'\n    killCharacter: (character_number) => {\n      logg('@ACTION OF POWER for character 1 - kill', character_number);\n      let all_cards = [...cards];\n      const theCardToKillIndex = cardsAPI.getCardIndexByCharacterNumber(character_number);\n      if ( typeof theCardToKillIndex === 'number' && theCardToKillIndex >= 0 ) {\n        all_cards[theCardToKillIndex].is_killed = true;\n        clonedHand.characterActThisTurn = 'kill';\n        gameAPI.setMessage('after_character_acts', (<h3>You killed {all_cards[theCardToKillIndex].name}!</h3>));\n        setCards(all_cards);\n        setHand(clonedHand);        \n        return;\n      }\n    },\n\n    // @MODEL:CARDS - updates the given card as 'stolen'\n    stealCharacter: (character_number) => {\n      logg('@ACTION OF POWER for character 2 - steal another card');\n      let all_cards = [...cards];\n      const theCardToStealIndex = cardsAPI.getCardIndexByCharacterNumber(character_number);\n      if ( typeof theCardToStealIndex === 'number' && theCardToStealIndex >= 0 ) {        \n        all_cards[theCardToStealIndex].is_stolen = true;\n        setCards(all_cards);\n        gameAPI.setMessage('after_character_acts', (<h3>You stole from {all_cards[theCardToStealIndex].name}!</h3>));\n        clonedHand.characterActThisTurn = 'steal';\n        setHand(clonedHand);\n        // TODOMESSAGE\n        return;\n      }\n    },\n\n  } // end cardsAPI\n    \n\n//                                P L A Y E R S \n//                                 __________\n//                               /           \\\n//                               |   0 . 0    |\n//                               |    /_      P\n//                               \\_   ___     /\n//                                 \\________/\n//                                  A. P. I.\n\n  const playersAPI = {\n\n\n    // @MODEL:PLAYER/CARDS\n    // WHAT: removes the card from the specified deck, and returns it\n    // ...\n    // @param playerIndex\n    // @param cardID: the ID of the card in the array cards. If null it takes random, if 'last-district-card' it takes the last\n    // @param times: number of cards to pick up, used when cardID : 'last-district-card'\n    // Status update: [..]\n    pickUpCard: ( { playerIndex= null, cardID = null, times= 1 } ) => {\n            \n      // 0 ) VALIDATION: get number of cards per turn, and check that we are ok\n      if (clonedHand.pickedCardsThisPlayerTurn >= gameAPI.getCurrentStageParams().maxCardsToPickup) {\n        console.log('Tried to pick up more cards than allowed');\n        return;\n      }\n\n      // 1) DATA: init the player and the card. If not player set, get current. If not card set, random.\n      let deck, grabLastDistrictCard;\n      \n      if (typeof(cardID) === 'number') {\n        const cardType = cardsAPI.getCardByID(cardID);\n        deck = (cardType === 'district') ? [...districtCards] : [...characterCards];\n        times = 1; // just to make sure we run it exactly 1 loop.\n      } else {\n        deck = [...districtCards];\n        grabLastDistrictCard = (cardID === 'last-district-card');\n      }\n      const thePlayerIndex = playerIndex || currentPlayer;\n      let playersUpdated = [...players];\n      let cardIndex, theCard;\n\n      logfn( `pickUpCard`, `ID ${cardID} by player ${playerIndex}` );\n      \n      if (!deck.length) {\n        logg('--- deck empty. exit');\n        return;\n      }\n\n\n      // WE TAKE times CARDS FROM THE DECK\n      \n      for (let i=0; i<times; i++) {\n\n        if (grabLastDistrictCard) {\n          if ( deck.length <= 0 ) {\n            logg('There are no more district cards. Total grabbed so far: ' +clonedHand.pickedCardsThisPlayerTurn);\n            cardID = null; // we dont do actions on the deck\n          } else {\n            cardID = deck[deck.length - 1].ID;\n          }\n        } \n\n        if (cardID) {\n          cardIndex = cardID ? cardsAPI.getCardIndexByID(cardID) : Math.floor(Math.random() * cards.length);\n          theCard = cards[cardIndex];\n                \n          // console.log(`Picking up card ${theCard.name} from ${theCard.type}, by player ${thePlayerIndex}`);\n        \n          // 2) @MODEL:CARDS Remove the card from deck. \n          deck.splice(deck.findIndex(card => card.ID === cardID), 1); // deck has one less item now\n          // Update the right deck (characters or district).  \n          \n          // 3) @MODEL:PLAYERS: include that card in the list of cards of that player.        \n          const thePlayer = Object.assign({}, playersUpdated[thePlayerIndex]);\n          thePlayer[`${theCard.type}Cards`].push(cardIndex); // ie. players[3].characterCards = [  3, 0, 1, 9] Where 9 is the index in array cards of the current card.\n          thePlayer[`${theCard.type}Cards`] = thePlayer[`${theCard.type}Cards`].filter(unique);\n          playersUpdated[thePlayerIndex] = thePlayer;\n          \n          // update param value.\n          clonedHand.pickedCardsThisPlayerTurn = clonedHand.pickedCardsThisPlayerTurn+1;\n          logg(`-- card grabbed ${theCard.name}, by ${players[thePlayerIndex].name}. Total ${clonedHand.pickedCardsThisPlayerTurn}`);\n        } \n      }  \n        \n      // setState calls\n      if (theCard) \n        if (theCard.type === 'character') setCharacterCards(deck); else setDistrictCards(deck);\n      setPlayers(playersUpdated);\n      setHand(Object.assign(clonedHand)); \n      //->>>> trigger State Event hand.pickedCardsThisPlayerTurn change\n        \n        \n    },\n\n    // returns bool\n    playerHasCharacter: ( plyrIndx, character_number) => {\n      logfn( `playerHasCharacter`, plyrIndx, character_number);\n      const { playerIndex: playerIndexWithCharacter } = playersAPI.getPlayerWhoOwnsCharacterCard(character_number);\n      return playerIndexWithCharacter === plyrIndx;\n    },\n\n    // @MODEL:PLAYERS [...]\n    getPlayerWhoOwnsCharacterCard: (character_number) => {\n      logfn( `getPlayerWhoOwnsCharacterCard`, character_number);\n      \n      const cardIndex = cardsAPI.getCardIndexByCharacterNumber(character_number);\n      let playerIndex = players.findIndex( player => player.characterCards.includes(cardIndex) );       \n      const player = (typeof playerIndex === 'number')? players[playerIndex] : {};\n      return { player, playerIndex: (playerIndex>=0? playerIndex : null), card: cards[cardIndex], cardIndex };\n    },\n    \n    getPlayerWhoOwnsDistrictCard: (cardID) => {\n      logfn( `getPlayerWhoOwnsCard`, cardID);\n      const cardIndex = cardsAPI.getCardIndexByID(cardID);\n      const playerIndex = players.findIndex( player => player.districtCards.includes(cardIndex) );\n      const player = players[playerIndex];\n      return { player, playerIndex, card: cards[cardIndex], cardIndex };\n    },\n\n    // @MODEL:PLAYERS\n    giveMoneyToPlayer: (coins = 0, playerIndex = null) => {\n      const playrIndx = (playerIndex === null) ? currentPlayer : playerIndex;\n      logfn( `giveMoneyToPlayer`, playrIndx + ' +' + coins);\n      if ( playrIndx === null ) return;\n      const playersTemp = [ ...players ];\n      playersTemp[playrIndx].money = playersTemp[playrIndx].money + coins;\n      setPlayers(playersTemp);  // doesnt trigger anything\n    },\n\n    // increases the .money of the player and updates the hand param 'districtsBuiltThisPlayerCharacter'.\n    payPlayerByDistrictCardsType: ( plIndx, districtType ) => {\n      \n      const districtCardsForThisCharacter = playersAPI.getBuildDistrictCardsForPlayerAndType(plIndx, districtType)\n          // for ( let cardIndx of districtCardsForThisCharacter ) {\n      if (districtCardsForThisCharacter.length) {        \n        playersAPI.giveMoneyToPlayer(districtCardsForThisCharacter.length, plIndx);\n        gameAPI.setMessage('before_coins_or_cards_btn', <p>You have received $ {districtCardsForThisCharacter.length} because you have the card {cardsAPI.getCalledCharacterCard().name} and {districtCardsForThisCharacter.length} built cards for this character</p>);\n        setHand(clonedHand, { districtsBuiltThisPlayerCharacter: districtCardsForThisCharacter.length });\n        logg('----hand.districtsBuiltThisPlayerCharacter: '+districtCardsForThisCharacter.length);\n      }\n\n    },\n\n    setPlayerWithCrownFirst: () => {      \n      // ie: [Peter, Mark, John*, Susanne] we convert it into [John*, Susanne, Peter, Mark]\n      logfn( `setPlayerWithCrownFirst ${players[crownPlayer]? players[crownPlayer].name : ''}` );\n      if (crownPlayer !== null) {\n        let playersPrev = [...players].slice(crownPlayer).concat([...players].slice(0, crownPlayer));\n        setPlayers(playersPrev);\n        setCrownPlayer(0);\n        return playersPrev; // just in case we want to use the modified array form the caller fn\n      }\n      return players;\n    },\n\n    // does the player have money to build any of his district cards?\n    // @return false if the player can't build at all\n    playerCanBuild: ( playerIndex, cardIndex = null) => {\n      const { allowedToBuild } = gameAPI.getCurrentStageParams();\n      \n      if ( typeof playerIndex !== 'number' || ( playerIndex !== currentPlayer )) return false; // only current player can build\n      if ( !allowedToBuild ) return false; // in the stage doesnt allow to build return false.\n      \n      const playrIndx = (playerIndex === null) ? currentPlayer : playerIndex;\n      \n      if ( allowedToBuild <= clonedHand.builtCardsThisPlayerTurn ) return false; // already built enough! \n\n      const playerBuildableDictrictCards = [ ...players[playrIndx].districtCards ]  // from the district cards\n            .filter( cardIndex => {                         \n              const have_money = cards[cardIndex].price <= players[playrIndx].money; // only the affordable\n              return have_money && (!cards[cardIndex].is_build); // and only the non built ones.\n            } );      \n      logg(`calculing buildable cards of ${players[playerIndex]? players[playerIndex].name : '++' + playerIndex + '!!!' }: `, playerBuildableDictrictCards);\n\n      if (cardIndex === null) // can build in general?\n        return playerBuildableDictrictCards.length ? playerBuildableDictrictCards : false;\n      else {\n        // can build THAT card?\n        if (!playerBuildableDictrictCards.length) return false;\n        return playerBuildableDictrictCards.includes(cardIndex); // if the card is included in the buildable cards, why not?\n      }\n    },\n\n    // @MODEL:PLAYERS - act for the magician (dependiente tienda comics)\n    swapDistrictCardsBetweenPlayers: ( player1Index = null, player2Index) => {\n      \n      const thePlayer1Index = player1Index || currentPlayer;\n      logfn( `swapDistrictCardsBetweenPlayers ${thePlayer1Index}`, player2Index);\n\n      // proceed to the swap of variables. We only swap the non built cards!\n      let tempPlayers = [ ...players ];\n      const tempPlayer1DistrictCards = [...players[thePlayer1Index].districtCards ];\n      tempPlayers[thePlayer1Index].districtCards = tempPlayer1DistrictCards.filter( ci => cards[ci].is_built ).concat( [ ...players[player2Index].districtCards.filter( ci => !cards[ci].is_built ) ] );\n      tempPlayers[player2Index].districtCards = [...players[player2Index].districtCards ].filter( ci => cards[ci].is_built ).concat( tempPlayer1DistrictCards.filter( ci => !cards[ci].is_built ) );\n      setPlayers(tempPlayers);\n\n      logg('@ACTION OF POWER for character 3: Magician - swap non built district cards with other player');\n      setHand(Object.assign(clonedHand, { characterActThisTurn: 'swap-cards' }));\n      gameAPI.setMessage('after_character_acts', (<h3>Your hand cards have been replaced with {players[player2Index].name} </h3>));\n    },\n\n    // @MODEL:PLAYERS/CARDS\n    destroyBuiltCardByWarlord: (card) => {\n      const { player : playerDestroyed, \n              playerIndex : playerIndexDestroyed, \n              cardIndex : cardIndexDestroyed } = playersAPI.getPlayerWhoOwnsDistrictCard(card.ID); // info about the destroyed card and its owner\n      \n      const currentCalledCard = cardsAPI.getCalledCharacterCard();\n      const { playerIndex: warlordPlayerIndex } = playersAPI.getPlayerWhoOwnsCharacterCard(8);\n      \n      logfn( `destroyBuiltCardByWarlord ${card.name}`, warlordPlayerIndex);\n\n      // VALIDATION\n      // TODO: the card can't be destroyed if the owner has the character Home (5)\n      if (playersAPI.playerHasCharacter(playerIndexDestroyed, 5)) {\n        console.log(`The card ${card.name} can't be destroyed. Its owner has the Bishop!`);\n        return false;\n      }\n      // TODO: the card can't be destroyed if it belongs to a complete district or a district with the Tower.\n      // TODO: only if it's build, it can be removed.\n      if (!card.is_built) {\n        console.log(`The card ${card.name} can't be destroyed. It is not built!`);\n        return false;\n      }\n      // only if the current player is Bart, and has money, it can be removed.\n      if (currentCalledCard['character-number'] !== 8) {\n        console.log(`The current character is not the Warlord, who is the only one allowed to destroy`);\n        return false;\n      }\n      if ( !(players[warlordPlayerIndex].money >= (card.price - 1 ))) {\n        console.log(`The current player doesnt have money to destroy that card, which costs ${(card.price - 1 )}`);\n        return false;\n      }\n      \n      if (!playersAPI.playerHasCharacter(currentPlayer, 8)) {\n        console.log(`The current Player hasnt the Warlord card. He cant destry any card.`);\n        return false;\n      }\n\n      \n      // remove card from player.\n      const indexInPlayersCards = playerDestroyed.districtCards.findIndex( index => cards[index].ID === card.ID );\n      if (!indexInPlayersCards) return false;\n      let newPlayers = [ ...players];\n      let distritCardsAfterDestroy = [ ...newPlayers[playerIndexDestroyed].districtCards ];\n      distritCardsAfterDestroy.splice(indexInPlayersCards, 1);\n      newPlayers[playerIndexDestroyed].districtCards = distritCardsAfterDestroy;      \n\n      // remove money from Barts player - This could be and should be currentPlayer \n      newPlayers[warlordPlayerIndex].money = newPlayers[warlordPlayerIndex].money - (card.price - 1);\n\n      setPlayers( newPlayers ); // the card has dissappeared for the player and the money from the current player\n\n      // change the param is_built to false\n      let newCard = Object.assign( { ...cards[cardIndexDestroyed] }, { is_built: false } );\n      let newCards = [ ...cards ];\n      newCards[cardIndexDestroyed] = newCard;\n      setCards( newCards ); // the card is not built anymore\n\n      // add it to the beggining of the deck \n      let tempDistrictCards = [...districtCards];\n      tempDistrictCards = [card].concat(tempDistrictCards); // this is the new districtCards deck\n      setDistrictCards(tempDistrictCards); // put the cards on the beginning\n\n      gameAPI.setMessage('after_character_acts', <p>You have destroyed the card {card.name} to player {players[playerIndexDestroyed].name} </p> );        \n\n      return true; // everything went ok, the card is destroyed.\n    },\n\n    getBuildDistrictCardsForPlayer: (playerIndex) => {\n      if ( typeof playerIndex !== 'number' ) return [];\n      let dCards = [...players[playerIndex].districtCards]; // array of cards index.\n      return dCards.filter( cardIndx => cards[cardIndx].is_built );\n    },\n\n    getBuildDistrictCardsForPlayerAndType: (plyrIndx, districtType) => {       \n      if ( typeof plyrIndx !== 'number' ) return [];\n      return playersAPI.getBuildDistrictCardsForPlayer(plyrIndx).filter(\n        cardIndx => cards[cardIndx][\"type-of-district\"] === districtType\n      );\n    }\n\n  } // end playersAPI\n\n\n  // END OF C O N T R O L L E R ++++++++++++++++++++++++++++++++++++++++\n\n\n  \n  // *** L I F E  C Y C L E (@MODEL:APP GAME; actions on states update) *******************\n  // *************************************************************\n \n\n/*\n        @@@@@@           @@@@@@\n      @@@@@@@@@@       @@@@@@@@@@\n    @@@@@@@@@@@@@@   @@@@@@@@@@@@@@\n  @@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@\n @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n      @@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@\n          @@@@@@@@@@@@@@@@@@@\n            @@@@@@@@@@@@@@@\n              @@@@@@@@@@@\n                @@@@@@@\n                  @@@\n                   @\n\n*/\n\n  // ONUPDATE currentPlayer (change of turn)------\n  const prevCurrentPlayer = usePrevious(currentPlayer);\n  useEffect(() => {\n    // Only if currentPlayer changes from a player to the next one:\n    if ( prevCurrentPlayer ===  currentPlayer) return;\n    logfn('currentPlayer UPDATE', prevCurrentPlayer, currentPlayer);\n    \n    if (gameAPI.getCurrentStageParams().loopPlayers)\n      gameAPI.resetHandParams();\n\n    // If we are in the stage of picking up district cards, the player takes 2 coins on the beginning.\n    if (hand.stage === 'district-selection') {\n      let giveTurnMoney = true;\n      giveTurnMoney = giveTurnMoney && !cardsAPI.getCalledCharacterCard().is_killed;\n      if (giveTurnMoney) {\n        playersAPI.giveMoneyToPlayer(2);\n        // clonedHand.messages = Object.assign({...clonedHand.messages}, { after_coins_or_cards_btn: <p>You won't be payed this turn ... :(</p> });\n      }\n      else {\n        gameAPI.setMessage('after_coins_or_cards_btn', <p>You won't be payed this turn ... :(</p> );        \n      }\n      setHand( clonedHand );        \n    }\n\n    // Sett more actions at setupCharacteer\n  }, [prevCurrentPlayer, currentPlayer, gameAPI, hand.stage, playersAPI, hand, clonedHand, cardsAPI]);\n\n\n  // ONUPDATE hand.pickedCardsThisPlayerTurn ------ every time a player picks a card from district or char deck (or the system discards a card from the char deck)\n  const prevPickedCardsThisPlayerTurn = usePrevious(hand.pickedCardsThisPlayerTurn);\n  useEffect(() => {\n    // Only if hand.pickedCardsThisPlayerTurn changes and we don't consider that the param is reset to 0:\n    if ( prevPickedCardsThisPlayerTurn ===  hand.pickedCardsThisPlayerTurn) return;\n    if ( !hand.pickedCardsThisPlayerTurn) return;\n\n    logfn('hand.pickedCardsThisPlayerTurn UPDATE', prevPickedCardsThisPlayerTurn, hand.pickedCardsThisPlayerTurn);\n\n    // depending on the stage, we see what's the limit.\n    \n    gameAPI.checkMoveToNextPlayerOrStage(true);\n\n  });\n\n\n  // ONUPDATE hand.characterActThisTurn ------ when a cahracter played his powe (kill, steal ...)\n  const prevCharacterActThisTurn = usePrevious(hand.characterActThisTurn);\n  useEffect(() => {\n    // Only if hand.characterActThisTurn changes and we don't consider that the param is reset to 0:\n    if ( prevCharacterActThisTurn ===  hand.characterActThisTurn) return;\n    if ( !hand.characterActThisTurn) return;\n\n    gameAPI.checkMoveToNextPlayerOrStage(true);\n\n    logfn('hand.characterActThisTurn UPDATE', prevCharacterActThisTurn, hand.characterActThisTurn);\n  });\n  \n  // ONUPDATE hand.coinsOrCardsThisTurn ------ when a player took the action ( money or cards ). ie, Mr burns receives 1 gold after action\n  const prevcoinsOrCardsThisTurn = usePrevious(hand.coinsOrCardsThisTurn);\n  useEffect(() => {\n    // Only if hand.coinsOrCardsThisTurn changes and we don't consider that the param is reset to 0:\n    if ( prevcoinsOrCardsThisTurn ===  hand.coinsOrCardsThisTurn) return;\n    if ( !hand.coinsOrCardsThisTurn) return;\n    \n    logfn(`hand.coinsOrCardsThisTurn UPDATE from ${prevcoinsOrCardsThisTurn} to ${hand.coinsOrCardsThisTurn}, stage ${hand.stage}`);\n\n    if (hand.stage === 'call-character-6') {\n      logg('@ACTION OF POWER for character 6 - on Update coinsOrCards, receives 1$ after choosing money/cards (Mr Burns).');\n      clonedHand.characterActThisTurn = 'collect-tax';\n      gameAPI.setMessage('after_coins_or_cards_action', <p>Merchant: You have received $ 1!!</p> );      \n      setHand( clonedHand );\n\n      playersAPI.giveMoneyToPlayer(1);\n    }\n    \n    if (hand.stage === 'call-character-7') {\n      playersAPI.pickUpCard( { cardID: 'last-district-card', times:2 } );\n      gameAPI.setMessage('after_coins_or_cards_action', <p>You receive 2 aditional cards, {} in total</p> );      \n      setHand( Object.assign(clonedHand, { characterActThisTurn: 'receive-extra-cards'} ) );\n      logg('@ACTION OF POWER for CHARACTER 7 - on Update coinsOrCards (Architect -Lenny&Carl) receives 2 district cards');\n    }\n\n\n    gameAPI.checkMoveToNextPlayerOrStage(true);\n\n  }, [prevcoinsOrCardsThisTurn, hand, gameAPI, playersAPI, clonedHand]);\n\n// ONUPDATE hand.canMoveNext ------ changes when an action lets the player to pass turn. this is updated by other states in the lifecycle\nconst prevCanMoveNext = usePrevious(hand.canMoveNext);\nuseEffect(() => {\n  // Only if hand.canMoveNext changes and we don't consider that the param is reset to 0:\n  if ( prevCanMoveNext ===  hand.canMoveNext) return;\n  if ( !hand.canMoveNext ) return;\n  if ( isEmpty(hand.canMoveNext) ) return; // we dont consider the param when reset\n\n  // if we get here, we moved into 'can move to next turn'\n\n  // automatically move to the next stage without more waiting.\n  if  (hand.canMoveNext.can && hand.canMoveNext.must) {\n    if ( ['district-selection', 'discard-character', 'character-selection-1', 'character-selection-2' ]\n                                      .includes(hand.stage) )\n      gameAPI.moveToNextPlayerOrStage();\n  }\n  \n\n  logfn(`hand.canMoveNext UPDATE from ${prevCanMoveNext} to ${hand.canMoveNext}, stage ${hand.stage}`);\n});\n\n\n\n\n  // ---- THE REAL LIFE CYCLE OF THE GAME - events on every stage -----------------------------\n  const prevStage = usePrevious(hand.stage);\n  // ONUPDATE hand.stage--------------------------\n  useEffect(() => {\n    // Only if hand.stage changes:\n    if ( prevStage ===  hand.stage) return;\n    logfn('hand.stage UPDATE', prevStage, hand.stage);\n\n    // inits everytime we move to next stage.\n    gameAPI.resetHandParams();\n\n    let playersX = [...players]; // cloning for updating.    \n    const { loopPlayers } = gameAPI.getCurrentStageParams(); \n\n    setCurrentPlayer( (loopPlayers)? 0 : null) ; // init currentPlayer, if it is a turn of players\n\n    // @MAYBECHANGE: I could just use if getCurrentStageOptions().characterAct to apply setUpCharacterSettings and avoud the switch\n\n\n    switch (hand.stage) {\n\n      case 'district-selection':\n          // now the actions are triggered by the selection of the cards by clickin on it.\n        break;\n\n      case 'discard-character':\n        // reset character cards for every player\n        playersX = playersAPI.setPlayerWithCrownFirst();\n        playersX.map( (player, i) => { \n          playersX[i].characterCards = [];\n        });\n        setPlayers(playersX);\n        const newCards = [...cards].map( c => Object.assign(c, { is_killed: false, is_stolen: false}) );\n        setCards(newCards); // reset cards properties changes in the previous turn.\n        cardsAPI.initDistrictOrCharacterDeck('character');\n        // from here CardsDeck > clicking in a char card triggers the picked card\n        break;\n      case 'character-selection-1' :\n        break;\n      case 'character-selection-2' : \n        break;\n      case 'call-character-1' :\n        // ACTION of char 1: THE ASSASSIN.\n        gameAPI.setUpCharacterSettings(1);        \n        break;\n      case 'call-character-2' :\n        // ACTION of char 2: THE THIEF.\n        gameAPI.setUpCharacterSettings(2);\n        break;\n      case 'call-character-3' :\n        // ACTION of char 3: THE MAGICIAN.\n        gameAPI.setUpCharacterSettings(3);\n        break; \n      case 'call-character-4' :\n        // ACTION of char 4: THE KING.\n        \n        gameAPI.setUpCharacterSettings(4);        \n        \n        break;\n      case 'call-character-5' :\n        // ACTION of char 5: THE BISHOP - cant be destroyed.\n        gameAPI.setUpCharacterSettings(5);\n        break;\n      case 'call-character-6' :\n        // ACTION of char 5: THE MERCHANT (Mr burns)- after action, takes 1 gold more. See update hand.coinsOrCardsThisTurn\n        gameAPI.setUpCharacterSettings(6); // See hand.coinsOrCardsThisTurn UPDATE - it will receive a coin when that triggers\n        break;\n      case 'call-character-7' :\n        gameAPI.setUpCharacterSettings(7);\n        break;\n      case 'call-character-8' :\n        gameAPI.setUpCharacterSettings(8);\n        break;\n\n      default:\n        break;\n    }\n\n\n    return () => {\n\n    }\n  }, [prevStage, hand.stage, crownPlayer, playersAPI, players, gameAPI, cardsAPI, currentPlayer, cards])\n\n  // *** end of LIFE CYCLE  **************************************\n  // *************************************************************\n \n\n\n/* ++++++++++++++++++++++++++++++++ V I E W ++++++++++++++++++++++++++++++++\n  /~~~\\/~~\\/~~~\\/~~~\\/~~\\/~~~\\                    /~~~\\/~~\\/~~~\\/~~~\\/~~\\/~~~\\\n  | /\\/ /\\/ /\\ || /\\/ /\\/ /\\ |                    | /\\ \\/\\ \\/\\ || /\\ \\/\\ \\/\\ |\n  \\ \\/ /\\/ /\\/ /\\ \\/ /\\/ /\\/ /                    \\ \\/\\ \\/\\ \\/ /\\ \\/\\ \\/\\ \\/ /\n   \\ \\/\\ \\/\\ \\/  \\ \\/\\ \\/\\ \\/                      \\/ /\\/ /\\/ /  \\/ /\\/ /\\/ /\n ,_/\\ \\/\\ \\/\\ \\__/\\ \\/\\ \\/\\ \\______________________/ /\\/ /\\/ /\\__/ /\\/ /\\/ /\\_,\n (__/\\__/\\__/\\____/\\__/\\__/\\________________________/\\__/\\__/\\____/\\__/\\__/\\__)\n*/\n\n\n\n\n  return (\n    <div className=\"App\">\n      <TopNav gameAPI={gameAPI} currentPlayer={currentPlayer} hand={hand} players={players} gameOptions={gameOptions} cards={cards} />\n      <div className='App__body'>\n        <div className='App__body-temporarymessage'>{temporaryMessage}</div>\n        <div className='container'>\n          <div className='row'>\n            <div className=' DevInfo col-2 border small'>\n              <Debug gameOptions={gameOptions} hand={hand} gameAPI={gameAPI} stages={stages} />\n            </div>\n            <div className='col-5' key='gfds4'>\n              <CardsDeck cards={cards} players={players} setPlayers={setPlayers} characterCards={characterCards} districtCards={districtCards} hand={hand} stages={stages} setHand={setHand} currentPlayer={currentPlayer} playersAPI={playersAPI} setCharacterCards={setCharacterCards} setDistrictCards={setDistrictCards} cardsAPI={cardsAPI} gameAPI={gameAPI} />\n            </div>\n            <div className='col-5' key='35tt5'>\n              <Players players={players} currentPlayer={currentPlayer} crownPlayer={crownPlayer} cards={cards} setCards={setCards} cardsAPI={cardsAPI} playersAPI={playersAPI} />\n            </div>\n          </div>\n        </div>\n        \n      </div>\n      <Footer players={players} crownPlayer={crownPlayer} currentPlayer={currentPlayer} cards={cards} setCards={setCards} cardsAPI={cardsAPI} />\n      {\n       gameOptions.dev ? (\n        <div className='devtools'>\n          <h5>District Deck</h5>\n          <div className='row district-deck'>\n            { districtCards.map( card => <div className='small-card' key={ 'devcard'+card.ID }><Card card={card} /></div>) }\n          </div>\n          <h5>Chars Deck</h5>\n          <div className='row character-deck'>\n            { characterCards.map( card => <div className='small-card' key={ 'devcard'+card.ID }><Card card={card}/></div>) }\n          </div>\n        </div>\n\n\n       ) : null\n\n      }\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './css/index.scss';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}