{"version":3,"sources":["components/NextTurnButton.js","helpers.js","components/TopNav.js","components/Card.js","components/ActionButton.js","components/CardsDeck.js","components/Player.js","components/Players.js","components/Footer.js","components/Debug.js","components/App.js","serviceWorker.js","index.js"],"names":["NextTurnButton","hand","gameAPI","canMoveNext","can","className","onClick","moveToNextPlayerOrStage","shuffle","array","sort","Math","random","unique","value","index","self","indexOf","isEmpty","obj","key","hasOwnProperty","logg","string","rest","arguments","length","console","log","Array","from","join","logfn","fn_name","str","args","renderObject","jsx","Object","keys","TopNav","cards","currentPlayer","players","gameOptions","useState","open","name","must","initDemoGame","startGame","Card","card","place","allowedToBuild","cardsAPI","isBuyable","classes","type","is_killed","is_stolen","e","preventDefault","buildCard","ID","data-cardid","Fragment","src","alt","image","description","getCardIndexByID","price","ActionButton","setHand","playersAPI","mustChooseCoinsOrCards","getCurrentStageParams","theCharacterCard","getCalledCharacterCard","handleCoinsOrCardsAction","action","clonedHand","assign","coinsOrCardsThisTurn","giveMoneyToPlayer","checkMoveToNextPlayerOrStage","pickUpCard","cardID","times","msg","messages","before_coins_or_cards_btn","msg_after","after_coins_or_cards_action","after_coins_or_cards_btn","btnClass","CardsDeck","characterCards","setCharacterCards","districtCards","setDistrictCards","setPlayers","removeRandomCharacterCard","clonedCardsArray","splice","floor","pickedCardsThisPlayerTurn","partialViewCharacter_1_and_2","charNum","eC","theKilledCardIndex","findIndex","c","getCardIndexByCharacterNumber","concat","filter","includes","partialViewCharacter_3","class","tempDistrictCards","listCurrentPlayerCard","map","cardIndex","is_built","numberOfCards","updatePlayers","cc","ca","i","lastCard","pop","push","characterActThisTurn","setMessage","ci","player","playerIndex","privateCards","swapDistrictCardsBetweenPlayers","partialViewCharacter_4","partialViewCharacter_5","partialViewCharacter_6","partialViewCharacter_7","partialViewCharacter_8","playersStoleable","plyr","indx","playerHasCharacter","bishopPlayerIndex","getPlayerWhoOwnsCharacterCard","builtCards","destroyable","money","destroyBuiltCardByWarlord","handleCardClick","stage","viewDistrictSelectionDeck","characterRound","parseInt","slice","lastIndexOf","viewCharacterSelectionDeck","theCard","characterAct","special_character_action_jsx","after_character_acts","playerCanBuild","viewWrapperCharacter","Player","crownPlayer","setCards","height","dCard","Players","wrapperClass","Footer","Debug","stages","dev","App","setCrownPlayer","number","builtCardsThisPlayerTurn","districtsBuiltThisPlayerCharacter","stageParamsThisTurn","setCurrentPlayer","temporaryMessage","loopPlayers","maxCardsToPickup","minCardsToPickup","usePrevious","ref","useRef","useEffect","current","loadCards","initPlayers","allPlayers","pickedCardsInThisTurn","initDistrictOrCharacterDeck","alert","resetHandParams","moveToNextStage","nextStage","forEach","stageName","moveStage","nextPlayer","only_return_true_or_false","canMove","shouldMove","allowedToMove","forcedToMove","setUpCharacterSettings","characterNumber","kingPlayerIndex","characted2PlayerIndex","clonedPlayers","payPlayerByDistrictCardsType","a","url","window","location","origin","fetch","then","response","json","repeatTimes","newCard","getCardByID","getCardByCharacterNumber","typeOfCard","shuffleBool","deck","all_cards","all_players","getPlayerWhoOwnsDistrictCard","killCharacter","character_number","theCardToKillIndex","stealCharacter","theCardToStealIndex","grabLastDistrictCard","thePlayerIndex","playersUpdated","thePlayer","plyrIndx","coins","playrIndx","playersTemp","plIndx","districtType","districtCardsForThisCharacter","getBuildDistrictCardsForPlayerAndType","setPlayerWithCrownFirst","playersPrev","playerBuildableDictrictCards","is_build","player1Index","player2Index","thePlayer1Index","tempPlayers","tempPlayer1DistrictCards","playerDestroyed","playerIndexDestroyed","cardIndexDestroyed","currentCalledCard","warlordPlayerIndex","indexInPlayersCards","newPlayers","distritCardsAfterDestroy","newCards","getBuildDistrictCardsForPlayer","cardIndx","prevCurrentPlayer","giveTurnMoney","prevPickedCardsThisPlayerTurn","prevCharacterActThisTurn","prevcoinsOrCardsThisTurn","prevCanMoveNext","prevStage","playersX","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.d4391a89.chunk.js","sourcesContent":["// This is called in CardsDeck.js, inside fn viewWrapperCharacter(). \nimport React from 'react';\nimport '../css/NextTurnButton.scss';\n\nfunction NextTurnButton({  hand, gameAPI }) {\n\n  \n  const handleClick = () => {\n    gameAPI.moveToNextPlayerOrStage(); // it should alway be moveToNextPlayer()\n  }\n\n  // we show the button if: we can move to the next turn\n  if (hand.canMoveNext.can) {\n    return <button className=\"btn btn-danger mb-3\" onClick={handleClick}>\n      Next turn\n    </button>\n  }\n  return null;\n}\n\nexport default NextTurnButton;","import React from 'react'\n// HELPERS\n\n// shuffles an array by reference. Don't need to use the return value. Use: \n// @param array: the array we want to shuffle\n// @return the array, altough the array given as an arg is already shuffleed\nexport function shuffle(array) {\n  // one method:\n  array.sort(() => Math.random() - 0.5);\n  return array;\n}\n\n// works with array, use it with filter. ie: const uniqueAges = ages.filter(unique)\nexport function unique(value, index, self) {\n\treturn self.indexOf(value) === index\n}\n\n// tells if an object is empty like : {}\nexport function isEmpty(obj) {\n    for(var key in obj) {\n        if(obj.hasOwnProperty(key))\n            return false;\n    }\n    return true;\n}\n\n// NOT USED\n// compares two array (it might have objects or anything inside) or objects (can be nested)\n// and returns true if they have the same values.\nexport function isEqual(value, other) {\n\n\t// Get the value type\n\tvar type = Object.prototype.toString.call(value);\n\n\t// If the two objects are not the same type, return false\n\tif (type !== Object.prototype.toString.call(other)) return false;\n\n\t// If items are not an object or array, return false\n\tif (['[object Array]', '[object Object]'].indexOf(type) < 0) return false;\n\n\t// Compare the length of the length of the two items\n\tvar valueLen = type === '[object Array]' ? value.length : Object.keys(value).length;\n\tvar otherLen = type === '[object Array]' ? other.length : Object.keys(other).length;\n\tif (valueLen !== otherLen) return false;\n\n\t// Compare two items\n\tvar compare = function (item1, item2) {\n\n\t\t// Get the object type\n\t\tvar itemType = Object.prototype.toString.call(item1);\n\n\t\t// If an object or array, compare recursively\n\t\tif (['[object Array]', '[object Object]'].indexOf(itemType) >= 0) {\n\t\t\tif (!isEqual(item1, item2)) return false;\n\t\t}\n\n\t\t// Otherwise, do a simple comparison\n\t\telse {\n\n\t\t\t// If the two items are not the same type, return false\n\t\t\tif (itemType !== Object.prototype.toString.call(item2)) return false;\n\n\t\t\t// Else if it's a function, convert to a string and compare\n\t\t\t// Otherwise, just compare\n\t\t\tif (itemType === '[object Function]') {\n\t\t\t\tif (item1.toString() !== item2.toString()) return false;\n\t\t\t} else {\n\t\t\t\tif (item1 !== item2) return false;\n\t\t\t}\n\n\t\t}\n\t};\n\n\t// Compare properties\n\tif (type === '[object Array]') {\n\t\tfor (var i = 0; i < valueLen; i++) {\n\t\t\tif (compare(value[i], other[i]) === false) return false;\n\t\t}\n\t} else {\n\t\tfor (var key in value) {\n\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\tif (compare(value[key], other[key]) === false) return false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If nothing failed, return true\n\treturn true;\n\n};\n\n// function for dev purposes\nexport function logg( string, obj = null, ...rest) {\n\tif (arguments.length === 1 ) \n\t\tconsole.log(string);\n\tif (arguments.length === 2 ) \n\t\tconsole.log(string, obj);\n\tif (arguments.length > 2 ) \n\t\tconsole.log( Array.from(arguments).join(\" -||- \") );\n\treturn;\n}\n\nexport function logfn ( fn_name, ...args ) {\t\n\tconst str = `**** FN ${fn_name} ****`;\n\tlogg( str, ...args );\n}\n\nexport function renderObject(obj) {\n\tlet jsx = null;\n\tif (!obj) return '';\n\tfor ( let key of Object.keys(obj) )\n\t\tif ( obj[key] === null )\n\t\t\tjsx = [ jsx, (<span className='d-block'>{key} >>> <i>null</i></span>) ];\n\t\telse if ( typeof obj[key] === 'object' )\n\t\t\tjsx = [ jsx, (<span className='d-block'>{key} >>> <i>Object</i></span>) ];\n\t\telse jsx = [ jsx, (<div  className='d-block'> { key  } >> <b>{ obj[key] }</b></div>) ]\n\treturn jsx;\n}","import React, { useState } from 'react'\nimport NextTurnButton from './NextTurnButton'\nimport { renderObject } from \"../helpers\";\n\nfunction TopNav({ cards, currentPlayer, hand, players, gameAPI, gameOptions }) {\n\n  const [open, updateOpen] = useState(false);\n\n  // returns player object\n  const getCurrentPlayer = () => players[currentPlayer]? players[currentPlayer] : {} ;\n\n  \n  return (\n    <div className={'TopNav container ' + (open ? 'open' : 'closed')}>\n      <div className='row text-center'>\n        <small className={ 'card col-4' }> { getCurrentPlayer().name } ({currentPlayer})</small>\n        <small className={ 'card col-4 bg-' + (hand.canMoveNext.can ? 'success' : 'danger ') } > can pass turn </small>\n        <small className={ 'card col-4 bg-' + (hand.canMoveNext.must ? 'success' : 'danger ') } > turn is finished </small>\n      </div>\n        \n        \n      <button className={'btn btn-primary btn-sm'} onClick={gameAPI.initDemoGame}>Load cards</button>\n      <button className={'btn btn-secondary btn-sm ' + ( cards.length? '' : 'd-none' ) } onClick={ () => gameAPI.startGame() }>Start game</button>\n    </div>\n  );\n}\n\nexport default TopNav;\n","import React from 'react'\nimport '../css/Card.scss';\n\nfunction Card({ card, place, allowedToBuild, cardsAPI }) {\n\n  if (!card) {\n    return <p>No card!</p>\n  }\n\n  // build card on click, if we are on the place===player-private and it's buildable\n  const handleClick = (e) => {\n    e.preventDefault();\n\n    if (card.type === 'district' && place === 'player-private') {     \n      if (cardsAPI)\n      cardsAPI.buildCard(card.ID);\n    }\n  }\n\n  const isBuyable = allowedToBuild; \n  let classes = \"Card \";\n\n\n  classes += `Card--${ card.type } Card--color-${(card[\"type-of-district\"] || card[\"character-number\"] || \"default\" )}`;\n  classes += card.is_killed ? \" Card--killed\" : \"\";\n  classes += card.is_stolen ? \" Card--stolen\" : \"\";\n  classes +=  isBuyable? \" hover-border cursor-pointer Card--is-buyable\" : ( place === 'player-private' ) ? \" Card--no-buyable\" : \"\";\n  \n  return (\n    <div className={ classes } onClick={ isBuyable? handleClick : null } data-cardid={ card.ID }>\n      <div className={'badge Card__badge Card__badge--color-' +(card[\"type-of-district\"] || card[\"character-number\"]) }>\n          <span className='position-absolute'> {card[\"character-number\"]? card[\"character-number\"] : <React.Fragment>&nbsp;</React.Fragment> } </span>        \n      </div>\n      { card.is_killed? ( <img className='Card__icon img-fluid' src=\"/imgs/is-killed.png\" alt='killed'/> ) : null  }\n      { card.is_stolen? ( <img className='Card__icon img-fluid' src=\"/imgs/is-stolen.png\" alt='stolen'/> ) : null  }\n      <img className=\"Card__image mx-auto img-fluid\" src={card.image} alt={ card.description} />\n      <p className=\"Card__title\">\n        {card.name} ID: { card.ID } / index: { (cardsAPI)? cardsAPI.getCardIndexByID(card.ID) : 'doknow'} \n        {\n          card.price? <span className=\"d-block\">$ {card.price} { card['extra-price']? `(+${card['extra-price']})` : '' }</span> : ''\n        }\n      </p>\n    </div>\n  );\n}\n\nexport default Card;\n","// This is called in CardsDeck.js, inside fn viewWrapperCharacter(). \n// Only used when the stage is a character call.\nimport React from 'react';\nimport '../css/ActionButton.scss';\n\nfunction ActionButton({  hand, setHand, currentPlayer, playersAPI, gameAPI, cardsAPI }) {\n\n  // Action to take Money or take cards\n  if (!hand) return\n  if ( null === currentPlayer) return null;\n  const { mustChooseCoinsOrCards } = gameAPI.getCurrentStageParams();\n\n  // if we are not in a call stage\n  const theCharacterCard = cardsAPI.getCalledCharacterCard();\n  if ( !theCharacterCard || theCharacterCard === {})\n    return null;\n  \n  // ---- End of VALIDATION ------\n\n  // when clicking on the selected action\n  const handleCoinsOrCardsAction = (action) => {\n\n    const clonedHand = Object.assign({}, hand);\n    \n    if (clonedHand.coinsOrCardsThisTurn) { // for some reason if I use 'hand' the value is not updated.\n      console.log(`action take ${action} is not allowed. You already performed your action (${clonedHand.coinsOrCardsThisTurn})`);\n      return;\n    }\n\n\n    // give 2 coins to the player\n    if ( action === 'money' ) {\n      playersAPI.giveMoneyToPlayer(2);\n      gameAPI.checkMoveToNextPlayerOrStage();\n    }\n    // give 2 cards to the player\n    if ( action === 'cards' ) {\n      console.log('Cards the player');\n      playersAPI.pickUpCard({ cardID: 'last-district-card', times: 2}); // this calls already to checkMoveToNextPlayerOrStage();\n    }\n\n\n    setHand( Object.assign(clonedHand, { coinsOrCardsThisTurn: action }) );\n    //->>>> trigger hand.coinsOrCardsThisTurn change\n  }\n\n  // --- End of the HANDLE CLICK --- \n\n\n  let msg = null;\n  \n  // Messages before the button, set up dynamically depending on actions\n  msg = [ msg, hand.messages.before_coins_or_cards_btn ];\n  // message about player action money/cards\n  if ( !mustChooseCoinsOrCards) {\n    // this means that this players is not allowed to take an action (ie, his called card is killed)\n    msg = [ msg, <h3 key='shutup'>No action allowed</h3> ];    \n  }\n \n  // Messages after the button, set up dynamically depending on actions\n  let msg_after = null;\n  msg_after = [ msg_after, hand.coinsOrCardsThisTurn ? hand.messages.after_coins_or_cards_action : hand.messages.after_coins_or_cards_btn ];\n\n  const btnClass = ( mustChooseCoinsOrCards && !hand.coinsOrCardsThisTurn) ? 'CardsDeck__actions--enabled btn-primary' : 'CardsDeck__actions--disabled btn-secondary';\n    \n  return (      \n    <div className=\"CardsDeck__actions\">\n      { msg } \n      { mustChooseCoinsOrCards? (\n        <React.Fragment>\n          { (!hand.coinsOrCardsThisTurn               \n                && !hand.messages.before_coins_or_cards_btn\n             )? <p key='k-4423'>Choose between taking 2 coins or 2 cards</p> : null }\n\n          <button className={ 'btn ' + btnClass + (hand.coinsOrCardsThisTurn === 'money'? ' btn-info ': '') } \n                  onClick={ () => handleCoinsOrCardsAction('money') } >\n            Money\n          </button>\n          <button className={ 'btn  ' + btnClass + (hand.coinsOrCardsThisTurn === 'cards'? ' btn-info ': '') }\n                  onClick={ () => handleCoinsOrCardsAction('cards') } >\n            Cards\n          </button>\n        </React.Fragment>\n      ) : null }\n      { msg_after }\n    </div>\n  );    \n\n}\n\nexport default ActionButton;","import React, { useState } from 'react'\nimport Card from './Card'\nimport ActionButton from './ActionButton'\nimport NextTurnButton from './NextTurnButton'\nimport '../css/CardsDeck.scss';\nimport { isEmpty, logg } from \"../helpers\";\n\nfunction CardsDeck({ cards, characterCards, setCharacterCards, districtCards, setDistrictCards, players, setPlayers, hand, setHand, currentPlayer, playersAPI, gameAPI, cardsAPI }) {\n              \n  // CONTROLLER ++++++++++++++++++++++++++++++++++++++++\n\n  // the turn of discard 1 card from the character deck. This could be in the original cardsAPI definition\n  cardsAPI.removeRandomCharacterCard = () => {\n    if (!characterCards.length) return null;\n    let clonedCardsArray = [ ...characterCards ];\n    clonedCardsArray.splice(Math.floor(Math.random() * clonedCardsArray.length), 1);\n    setCharacterCards(clonedCardsArray);\n\n    // @MAYBECHANGE: I think we could avid this and simply move to nextStage here.\n    const clonedHand = Object.assign({}, hand);\n    setHand(Object.assign(clonedHand, { pickedCardsThisPlayerTurn : (hand.pickedCardsThisPlayerTurn + 1)}) ); \n    //->>>> trigger hand.pickedCardsThisPlayerTurn change\n  }\n\n\n  // VIEWS:\n\n  // 2) View on stage 'district-selection'\n  const viewDistrictSelectionDeck = () => {\n    if (hand.stage !== 'district-selection') return <hr />;\n   \n    const clickHandle = () => {\n      playersAPI.pickUpCard({ cardID: 'last-district-card', times: 4 } );\n    }\n\n    return (\n      <ul className='row list-unstyled'>\n        <li className='offset-3 col-6 pt-4' onClick={ clickHandle }>\n          <img className=\"m-auto img-fluid\" src=\"/imgs/back.png\" alt=\"Click the card to pick it up!\" />\n        </li>\n      </ul>\n    );\n  }\n\n  const viewDiscardCharacterDeck = () => {\n    if (hand.stage !== 'discard-character') return <hr />;\n    return (\n      <div>\n        <p>Click to remove one random card from the characters' deck</p>\n        <ul class='d-inline-flex p-0 justify-content-center flex-wrap' onClick={ () => { cardsAPI.removeRandomCharacterCard() } }>\n        {\n          cards.filter( c => c.type === 'character' ).map( card => {\n            return (<li class='Card small-card cursor-pointer hover-border'><img className=\"small-card img-fluid\" src=\"/imgs/back.png\"  alt=\"\" /></li>);\n          } )\n        }\n        </ul>        \n      </div>\n    );\n  }\n\n  // 2) View on stage 'character-selection'\n  const viewCharacterSelectionDeck = () => {\n    if (!hand.stage || hand.stage.indexOf('character-selection') < 0) return <hr />;\n    const characterRound = parseInt(hand.stage.slice(hand.stage.lastIndexOf('-') + 1)); // grabs 2 from 'character-selection-2' \n    return (\n      <React.Fragment>\n      <p>Select your {characterRound===1?'first':'second'} character, {typeof currentPlayer === 'number'? players[currentPlayer].name : ''}</p>\n      <ul className='row small-cards px-0'>\n        {characterCards.map(card => {\n          return (\n            <li key={card.ID} className='col-3 my-2 list-unstyled' onClick={ (e) => playersAPI.pickUpCard({ cardID: card.ID } ) }>\n              <Card card={card} />\n            </li>\n          );\n        })}\n      </ul>\n      </React.Fragment>\n    );\n\n  }\n\n  const viewWrapperCharacter = () => {    \n\n    if (!hand) return;\n    if (!hand.stage) return;\n    const theCard = cardsAPI.getCalledCharacterCard();\n    if ( !theCard || isEmpty(theCard) ) return;\n    \n    // find card for the current character\n    if (!theCard) return <p>No card found for the character</p>\n \n    // init params for this hand:\n    const { characterAct, mustChooseCoinsOrCards, allowedToBuild } = gameAPI.getCurrentStageParams();\n\n    // init the jxs for the right column\n    let special_character_action_jsx = null;\n\n    if ( null === currentPlayer) { // this was set when (!playersAPI.getPlayerWhoOwnsCharacterCard(characterNumber))\n      special_character_action_jsx = (<p key='p-smt'>\n                Nobody has the character {theCard.name} <br/>\n      </p>);\n    }\n    else {\n      // The character act for the magician can happen before the coinOrCards decision\n      if ( characterAct && hand.characterActThisTurn === false && theCard[\"character-number\"] === 3)\n        special_character_action_jsx = partialViewCharacter_3();\n\n      // Normally, The character act sohuld happen after the Player action is taken\n      if (hand && hand.coinsOrCardsThisTurn)\n        // could check to write a msg of characted already acted\n        if ( characterAct && hand.characterActThisTurn === false ) \n        switch (theCard[\"character-number\"]) {\n          case 1:\n          case 2:\n            special_character_action_jsx = partialViewCharacter_1_and_2(theCard[\"character-number\"]);\n            break;    \n          case 3:\n            break;\n          case 4:\n            special_character_action_jsx = partialViewCharacter_4(); break;\n          case 5:\n            special_character_action_jsx = partialViewCharacter_5(); break;\n          case 6:\n            special_character_action_jsx = partialViewCharacter_6(); break;\n          case 7:\n            special_character_action_jsx = partialViewCharacter_7(); break;\n          case 8:\n            special_character_action_jsx = partialViewCharacter_8(); break;\n          default: break;\n        }\n    }\n\n    if ( typeof currentPlayer === 'number' ) { \n      // show text of after chaacter acted. This is set during the action of the char.\n      if ( hand.characterActThisTurn ) {\n        if (hand.messages.after_character_acts)  {\n          special_character_action_jsx = [ special_character_action_jsx, hand.messages.after_character_acts ];\n        }\n        // default msg after character did his action\n        if (mustChooseCoinsOrCards && !hand.coinsOrCardsThisTurn)\n          special_character_action_jsx = [ special_character_action_jsx, (<p key='shutup1'>You can take your action - grab money or district cards - </p>) ];\n        if ( hand.canMoveNext.can )\n          special_character_action_jsx = [ special_character_action_jsx, (<p key='shutup2'>You can pass turn to the next character.</p>) ];\n        if ( playersAPI.playerCanBuild(currentPlayer) )\n      special_character_action_jsx = [ special_character_action_jsx, (<p key='shutup3'>Or you can build {allowedToBuild} district{allowedToBuild>1? 's' : ''}.</p>) ];  \n      }\n    }\n\n    // add description of the card before the inteaction act from the character.\n            \n    return (\n      <div className='container'>\n        <div className='row'>\n          <div className='col-4' key='2356'>\n            <Card card={ theCard } />\n\n           { ( characterAct ) ? ( <p key='sthn-more'>{theCard.description}</p> ) : null }\n    \n          </div>\n          <div className='col-8' key='2793'>\n            \n            <ActionButton hand={hand} setHand={setHand} currentPlayer={currentPlayer} playersAPI={playersAPI} gameAPI={gameAPI} cardsAPI={cardsAPI} />\n\n            { special_character_action_jsx }\n\n            <NextTurnButton hand={hand} gameAPI={gameAPI} />\n\n\n          </div>\n        </div>\n      </div>\n\n    )\n  }\n\n  // Assassin and Thief CALL. Show the card (the assass or thief) and the list of characters to select one.\n  const partialViewCharacter_1_and_2 = (charNum) => {\n    // the list of characters cards to show.\n\n    // characters you can't steal from: the assassin or the assassin target (is_killed).\n    let eC = []; // this var could be called \"extra characters you can't touch\", but I call it ec.\n    if (charNum === 2) {\n      \n      const theKilledCardIndex = cards.findIndex( c => c.is_killed );\n      eC = [ cardsAPI.getCardIndexByCharacterNumber(1) ].concat( (theKilledCardIndex >= 0) ? [theKilledCardIndex] : [] ); // index of cards\n    }\n\n    // characterss except the assasin and except the other character that the player has\n    const characterCards = [...cards ].filter(card => \n        card.type && card.type === 'character' \n        && card['character-number'] !== charNum \n        && !players[currentPlayer].characterCards.includes( cardsAPI.getCardIndexByID(card.ID) )  // don't show you chanracters. dont kill you self!\n        && !eC.includes( cardsAPI.getCardIndexByID(card.ID) )  // don't show the excluded characters, which are the killer and eny killed characted.\n    );\n\n    const clickHandle = (selected_character_number) => {\n      switch (charNum) {\n        case 1: cardsAPI.killCharacter(selected_character_number);\n          break;\n        case 2: cardsAPI.stealCharacter(selected_character_number);\n          break;\n        default: break;\n      }      \n    }\n\n    return (\n      // show all character cards except the assassin and you own char\n      <React.Fragment>        \n        <p>Select the character that you want to { charNum === 1 ? 'kill' : 'steal from' } </p>\n        <ul className=\"list-unstyled row CardsDeck__character-pickup\">\n        { \n          characterCards.map( (card, i) => {\n            return  ( <li key={'charno-'+i} className=\"col-4 px-0 pb-3\" onClick={ (e) => clickHandle(card['character-number']) }>\n                        <Card key={card.ID} card={card} />\n                      </li> );                \n          } ) }\n        </ul>        \n        { // extra info about the characters you cant steal from\n        (charNum === 2)? <small>          \n            You can't steal from {                 \n                eC.map( (cardIndex, i) => \n                  (((i+1) === eC.length) && (eC.length > 1) ? ' or ' : (i?', ':'') ) \n                  + cards[cardIndex].name )\n                }  </small> : null }\n      </React.Fragment>\n    );\n  }\n\n  // 3: the magician: shows all players and you have to select 1 of them or the deck.\n  const partialViewCharacter_3 = () => {\n    \n    // put current cards on the beggining of districtCards deck, and take same amount from top.    \n    const handleDiscardCards = () => {\n      let tempDistrictCards = [...districtCards];\n      let listCurrentPlayerCard = players[currentPlayer].districtCards.map( cardIndex => ( cards[cardIndex] ) ).filter( card => !card.is_built );\n      tempDistrictCards = listCurrentPlayerCard.concat(tempDistrictCards); // this is the new districtCards deck\n      setDistrictCards(tempDistrictCards); // put the cards on the beginning\n      \n      // now pick same amount of cards.\n      const numberOfCards = listCurrentPlayerCard.length;      \n      let updatePlayers = [...players];\n      // remove the private cards from player. This is a little long but basically inits the district cards of the player to the built ones (so basically has removed the ones not built)\n      updatePlayers[currentPlayer].districtCards = updatePlayers[currentPlayer].districtCards.filter(cc => !listCurrentPlayerCard.map( ca => cardsAPI.getCardIndexByID(ca.ID) ).includes(cc)); // discard the cards\n      \n      // get the last top cards from district deck\n      for (let i = 0; i < numberOfCards; i++) {\n        let lastCard = tempDistrictCards.pop();\n        updatePlayers[currentPlayer].districtCards.push(cardsAPI.getCardIndexByID(lastCard.ID));\n      }\n      setPlayers(updatePlayers);\n\n      logg('@ACTION OF POWER for character 3: Magician - replace cards with the deck');\n      setHand(Object.assign({...hand}, { characterActThisTurn: 'replaced-cards' }));\n      gameAPI.setMessage('after_character_acts', (<h3>Your cards have been replaced by cards on the deck</h3>));\n    }\n    // now the view\n    return (\n      <React.Fragment>\n        <div className=\"row\">\n          <div className=\"col-12 mb-4\">Select, if you want how you want to discard your hand</div>\n          <div className=\"col-12\">\n            {\n            (hand.canMoveNext.can) ?  \n              <button class='btn btn-danger mb-4' onClick={gameAPI.moveToNextPlayerOrStage} >Don't discard and move to next player</button> \n              : \n              null\n            }\n            <button className=\"btn btn-primary w-100\" onClick={handleDiscardCards}>\n              Discard on Deck\n              <ul className=\"d-inline-flex list-unstyled extra-small-cards\">\n                {  // show back of cards for the non built ones\n                players[currentPlayer].districtCards.filter( ci => !cards[ci].is_built ).map( ci => {\n                  return (<li key={'dd' + ci} ><img className=\"img-fluid\" src=\"/imgs/back.png\"  alt=\"\" /> </li>);\n                } )  }\n              </ul>\n            </button>\n          </div>\n          <hr className='w-100'/>\n          { players.map( (player, playerIndex) => {\n            \n            const privateCards = player.districtCards.filter( cardIndex => !cards[cardIndex].is_built );\n            return (\n              (playerIndex === currentPlayer)? null\n              :\n              ( \n                <div key={'k'+playerIndex} className=\"col-sm\" onClick={ () => playersAPI.swapDistrictCardsBetweenPlayers( null, playerIndex) } >\n                  <button className={ 'mb-3 btn ' + (privateCards.length? ' btn-primary ' : '') }>\n                    <p className=\"mb-0\"> \n                      Exchange cards with <b>{player.name}</b> \n                      <small className='d-block'>{privateCards.length} cards</small>\n                    </p>\n                    { \n                      ( !privateCards.length) ? \n                          ( <p>No cards</p> ) \n                          :\n                          ( \n                            <ul className=\"d-inline-flex list-unstyled\">\n                            { privateCards.map( (c,i) => <li key={'dd' + i} ><img className=\"small-card img-fluid\" src=\"/imgs/back.png\"  alt=\"\" /> </li> )  } \n                            </ul> \n                          )\n                    }\n                  </button>\n                </div>\n              )\n            );\n          }) }\n        </div>\n      </React.Fragment>\n    );\n  }\n\n  // 4: the king\n  const partialViewCharacter_4 = () => {    \n    return (\n      <div>\n        <p> You get the crown. You will start next turn. </p>\n      </div>\n    );\n  }\n\n  const partialViewCharacter_5 = () => {\n    return (\n      <div>        \n        You are inmune to any attack from the Warlord\n      </div>\n    );\n  }\n\n  // the merchant (Mr Burns)\n  const partialViewCharacter_6 = () => {\n    // the money is given in lifecycle hand.coinsOrCardsThisTurn update.\n    if (gameAPI.getCurrentStageParams().mustChooseCoinsOrCards) {\n     if (!hand.coinsOrCardsThisTurn) \n        return <p>You will receive $ 1 after taking your action </p>    \n      // return <div> There you go!. You have $ 1 more. </div> we do it tiwh the message param\n    }\n    return null;\n  }\n\n  // the architect - receives 2 cards and can build 3 cards\n  const partialViewCharacter_7 = () => {\n    if (gameAPI.getCurrentStageParams().mustChooseCoinsOrCards) {\n      if (!hand.coinsOrCardsThisTurn)      \n        return ( <React.Fragment>\n            <p>You will receive 2 cards after taking your action </p>    \n            <p>You can build up to ${gameAPI.getCurrentStageParams().allowedToBuild} cards this turn. </p>    \n            </React.Fragment> \n        );\n      return <div> There you go!. You took { hand.pickedCardsThisPlayerTurn } cards in your hand. Happy building!</div>\n    }\n    return false;\n  }\n\n  // Bart, can destroy one district card built\n  const partialViewCharacter_8 = () => {\n    // destroying the card\n    const handleCardClick = (card) => {\n      if (playersAPI.destroyBuiltCardByWarlord(card)) {\n        setHand(Object.assign({...hand}, { characterActThisTurn: 'destroy-card' }));\n        logg('@ACTION OF POWER for character 8: Warlord - destroys a card');\n      }\n    }\n\n    logg('@ACTION OF POWER for character 5 - The player with this card can not be destroyed');\n    const playersStoleable = players.filter( (plyr,indx) => (indx !== currentPlayer) && (!playersAPI.playerHasCharacter( indx, 5)) );\n    const { playerIndex: bishopPlayerIndex } = playersAPI.getPlayerWhoOwnsCharacterCard(5);\n    \n    return (\n      <div>        \n        <p>Select the district you want to destroy</p>\n        {\n          (bishopPlayerIndex !== currentPlayer && typeof bishopPlayerIndex === 'number' && bishopPlayerIndex >= 0)? (\n              <p>You can't attact <b>{players[bishopPlayerIndex].name }</b>, because he has the Bishop character.</p>\n          ) : null\n        }\n        { \n        playersStoleable.map(( player, playerIndex )=> {\n          const builtCards = player.districtCards\n                              .filter( cardIndex => cards[cardIndex].is_built )\n                              .map( ( cardIndex, i ) => cards[cardIndex] );       \n          return ( \n            <div key={ ' player-to-destroy-' + playerIndex} >\n              <h3>{ player.name } <small> {builtCards.length} cards </small></h3>            \n              { !builtCards.length ? (<p>No cards to destroy</p>) : (\n                <ul className='list-unstyled'>\n                { builtCards.map( card => {\n                  const destroyable = (card.price - 1) <= player.money;\n                  return (\n                    <li className={ 'small-card col-sm ' + (destroyable? 'destroyable' : 'undestroyable') }\n                        onClick={ () => handleCardClick(card) }\n                        key={ 'destroy-card-' + card.ID }\n                    >\n                      <Card card={card} />\n                    </li>\n                    ) \n                  }) \n                }\n                </ul>\n              ) }\n            </div>\n          )\n        })\n        }\n      </div>\n    );\n  }\n\n\n  return (\n    <div className=\"CardsDeck text-center\">\n      {viewDistrictSelectionDeck()}\n      {viewDiscardCharacterDeck()}\n      {viewCharacterSelectionDeck()}\n      {viewWrapperCharacter()}      \n    </div>\n  );\n}\n\nexport default CardsDeck;\n","import React, { useState } from 'react';\nimport Card from './Card'\n\nimport '../css/Player.scss';\n\n// @player: { name: 'Peter', characterCards: [ ... ], money: 5 .. }\nfunction Player({ player, index, playersAPI, crownPlayer, cards, setCards, cardsAPI }) {\n\n  //  + + + + MODEL + + + +\n  /* \n  {\n      \n  }\n  */\n \n  return ( \n          <React.Fragment>\n            <div className='row'>\n              <div className='col-6'>\n                <h3 className=\"d-block\">{player.name}</h3>              \n              </div>\n              <div className='col-3'>\n                { (crownPlayer === index )? (<img className='Card__icon img-fluid h-100' src=\"/imgs/crown.png\" height='50' alt='crown'/> ) : null }\n              </div>\n              <div className='col-3'>\n                $ {player.money}\n              </div>\n            </div>\n\n            <div className='row'>            \n              <div className='col-2 extra-small-cards'>                \n                { player.characterCards.map( ( cardIndex, i ) => {\n                  const card = cards[cardIndex];\n                  return (\n                    <Card card={card} key={i} place={'character-private'} />\n                    )\n                  }) }\n              </div>\n              <div className='col-10'>              \n                <div className='row extra-small-cards'>                  \n                  { player.districtCards.filter( cardIndex => !cards[cardIndex].is_built )\n                        .map( ( cardIndex, i ) => {\n                            const dCard = cards[cardIndex];\n                            // TODO: make clicable if the currentPlayer has money to buy it!                            \n                            return (\n                              <Card key={'cc-'+cardIndex} place={'player-private'}  card={dCard} allowedToBuild={playersAPI.playerCanBuild(index, cardIndex)} cardsAPI={cardsAPI} />\n                              )\n                    }) }\n                </div>\n                <hr />\n                <div className='row extra-small-cards'>\n                { player.districtCards.filter( cardIndex => cards[cardIndex].is_built ).map( ( cardIndex, i ) => {\n                    const card = cards[cardIndex];\n                    return (\n                      <Card card={card} key={i} place={'player-built'} player={player} cards={cards} setCards={setCards} />\n                      )\n                    }) }\n                </div>\n              \n              </div>\n            </div>\n          </React.Fragment>\n         );\n}\n       \nexport default Player;\n","import React from 'react'\nimport Player from './Player'\n\n// @players: array of player { name: 'Peter', cards: [ ... ], money: 5 }\nfunction Players({ players, currentPlayer, crownPlayer, cards, setCards, cardsAPI, playersAPI }) {\n  \n  return (\n    <div className=\"Players\">\n      {\n        players.map( (player, index) => {\n         const isCurrentPlayer = index === currentPlayer;\n         const wrapperClass = \"Players__player-wrapper \" + (isCurrentPlayer? 'Players__player-wrapper--active' : '');\n         return (\n            <div key={'Player'+index} className={wrapperClass}>\n              <Player player={player} index={index} playersAPI={playersAPI} crownPlayer={crownPlayer} cards={cards} setCards={setCards} cardsAPI={cardsAPI} />\n            </div >\n          )\n        }\n        )\n      }\n    </div >\n  );\n}\n\nexport default Players;\n","import React, { useState } from 'react';\nimport Players from './Players';\n\nfunction Footer({ players, crownPlayer, currentPlayer, cards, setCards, cardsAPI }) {\n  return (\n    <footer className=\"Footer\">\n      This is the footer\n    </footer>\n  );\n}\n\nexport default Footer;\n","import React from 'react'\nimport { renderObject } from \"../helpers\";\n// import '../css/Debug.scss';\n\nfunction Debug({ gameOptions, hand, gameAPI, stages }) {\n\n  return (\n    <React.Fragment>\n    <h5 key='874'>Hand situation</h5>\n    { gameOptions.dev ? renderObject(hand) : null }\n    <hr/>        \n    <h5>Stage original settings</h5>\n    <div className=\"opacity-50\">\n      { gameOptions.dev ? renderObject(hand.stage? stages[hand.stage] : null) : null }\n    </div>\n    <hr/>\n    <h5 key='9843'>Stage actual settings</h5>\n    <div key='fds732'>\n      { gameOptions.dev ? renderObject(gameAPI.getCurrentStageParams()) : null }\n    </div>\n    </React.Fragment>\n\n  );\n}\n\nexport default Debug;\n","/*TODO:\n\n  Al construir, evitar q se puedan construir dos cartas iguales. (actualizar allow to build, buildable card)\n  BUG: turno lenny & card. Escoger cartas y no dinero. A acabar la accion se ejecuta la Character Act, q es tomar 2 cartas mas. Pero la turn param pickedCardsThisPlayerTurn se queda en 2 y no 4.\n*/\nimport React, { useState, useEffect, useRef } from 'react'\nimport TopNav from './TopNav';\nimport CardsDeck from './CardsDeck';\nimport Card from './Card';\nimport Footer from './Footer';\nimport Players from './Players';\nimport Debug from './Debug';\nimport '../css/App.scss';\nimport { shuffle, unique, isEmpty, logg, logfn, renderObject } from \"../helpers\";\n\n\nfunction App() {\n\n  // M O D E L +++++++++++++++++++++++++++++++++++++++\n  const [cards, setCards] = useState([]); // [ {cardOjb}, {cardObj} ... ]\n  const [characterCards, setCharacterCards] = useState([]); // [ {cardOjb}, {cardObj} ... ] (it would have been better a list of index)\n  const [districtCards, setDistrictCards] = useState([]);\n  const [players, setPlayers] = useState([]); // [ {playerObj}, {playerObj} ... ]\n  const [crownPlayer, setCrownPlayer] = useState(null); // set to the player index\n  const [hand, setHand] = useState({ number: null, \n                                     // stage: THIS is IMPORTANT info in the game. Tells in what stage we are. Goes together with 'stages' var.\n                                     stage: null,\n                                     // THIS STATE CHANGE trigger the Events of the game and allow to change the stage.\n                                     pickedCardsThisPlayerTurn: 0, // EVENT: pick up a card \n                                     builtCardsThisPlayerTurn: 0, // EVENT: build a district\n                                     coinsOrCardsThisTurn: false, // if false, no action is allowed. (action means either take 2 coins or grab 2 district cards)\n                                     characterActThisTurn: null, // kill, thief ... Only for character call turn\n                                     canMoveNext: {}, // {can: bool, must: bool} tells if the current turn can be finished (false if there sre still mandatory actions to be taken in the turn)\n                                     districtsBuiltThisPlayerCharacter: 0, // only for the call-character stages. It's the number of cards for the current character, and built by the player who owns the current character.\n                                     stageParamsThisTurn: {}, // we initialize this from 'stages' var, every time hand.stage changes.\n                                     messages: {\n                                       before_coins_or_cards_btn: null,\n                                       after_coins_or_cards_btn: null,\n                                       after_coins_or_cards_action: null,\n                                       after_character_acts: null,\n                                     }\n                                     }); // starts in 0. Every complete hand increments\n  const [currentPlayer, setCurrentPlayer] = useState(null); // index of player from the 'players' array. If null the hand didnt start\n  const [temporaryMessage, setTemporaryMessage] = useState(null);\n  const [gameOptions, setgameOptions] = useState({\n    dev: true\n  });\n\n  const stages = {\n                  'district-selection' :    { loopPlayers: true, maxCardsToPickup: 4, minCardsToPickup: 4},\n                  'discard-character':      {maxCardsToPickup: 1, minCardsToPickup: 1},\n                  'character-selection-1' : { loopPlayers: true, maxCardsToPickup: 1, minCardsToPickup: 1},\n                  'character-selection-2' : { loopPlayers: true, maxCardsToPickup: 1, minCardsToPickup: 1}, \n                  'call-character-1' : { mustChooseCoinsOrCards: true, characterAct: 'mandatory', maxCardsToPickup: 2, allowedToBuild: 1 },\n                  'call-character-2' : { mustChooseCoinsOrCards: true, characterAct: 'mandatory', allowedToBuild: 1 },\n                  'call-character-3' : { mustChooseCoinsOrCards: true, characterAct: 'optional', allowedToBuild: 1 },\n                  'call-character-4' : { mustChooseCoinsOrCards: true, characterAct: 'automatic', allowedToBuild: 1 },\n                  'call-character-5' : { mustChooseCoinsOrCards: true, characterAct: 'none', allowedToBuild: 1 },\n                  'call-character-6' : { mustChooseCoinsOrCards: true, characterAct: 'automatic', allowedToBuild: 1 },\n                  'call-character-7' : { mustChooseCoinsOrCards: true, characterAct: 'automatic', allowedToBuild: 3 }, // the architect can build up to 3 cards\n                  'call-character-8' : { mustChooseCoinsOrCards: true, characterAct: 'optional', allowedToBuild: 1 },\n  };\n  \n  const clonedHand = { ...hand }; // we define this globally, so if two setState happen in the same refresh, the second takes the updated value from the first.\n\n\n  // Helper - use it with a state param. ie const prev = usePrevious(cards)\n  const usePrevious = value => {\n    const ref = useRef();\n    useEffect(() => {\n      ref.current = value;\n    });\n    return ref.current;\n  };\n\n  // C O N T R O L L E R ++++++++++++++++++++++++++++++++++++++++\n\n\n                /*        G A M E   A.P.I\n                _______________          |*\\_/*|________\n                |  ___________  |        ||_/-\\_|______  |\n                | |           | |        | |           | |\n                | |   0   0   | |        | |   0   0   | |\n                | |     -     | |        | |     -     | |\n                | |   \\___/   | |        | |   \\___/   | |\n                | |___     ___| |        | |___________| |\n                |_____|\\_/|_____|        |_______________|\n                  _|__|/ \\|_|_.............._|________|_\n                / ********** \\            / ********** \\\n              /  ************  \\        /  ************  \\\n */\n  const gameAPI = {\n    initDemoGame: () => {\n      cardsAPI.loadCards();\n      gameAPI.initPlayers(['Giuseppe', 'Guillauseppe', 'Phillipseppe']);\n    },\n    \n    // @MODEL:PLAYERS - INIT\n    // @players: array with names of the players , ie [ 'Peter', 'Mary', 'Ignatius' ]\n    // inits the state players.\n    initPlayers: (players) => {\n      logfn( 'initPlayers', [...arguments ]);    \n      const allPlayers = players.map(name => ({\n        name,\n        money: 0,\n        characterCards: [], // array of indexes in 'cards' array\n        districtCards: [],\n        pickedCardsInThisTurn: 0\n      }) );\n      // optional: shuffle the array\n      setPlayers(allPlayers);\n    },\n      \n    // @MODEL:APP game\n    startGame: () => {\n      logfn( 'startGame', [...arguments ]);\n\n      if (!cards.length) {\n        alert('load the cards first');\n        return;\n      }\n      // TODO: validation. We can start a new hand only when the game didnt start or when the last player finished his turn\n\n      // When we change the stage we trigger the useEffect to shuffle the decks\n      setCurrentPlayer(0); //->>> currentPlayer change trigger\n      const keys = Object.keys(stages);\n      setHand(Object.assign( clonedHand, { stage: keys[0] })); // set to initial stage\n      setCrownPlayer(0);  \n      cardsAPI.initDistrictOrCharacterDeck('district', true);\n    },\n\n    resetHandParams: () => {\n      logfn( 'resetHandParams', [...arguments ]);  \n\n      clonedHand.stageParamsThisTurn = (clonedHand && clonedHand.stage)? stages[clonedHand.stage] : {};      \n      clonedHand.pickedCardsThisPlayerTurn= 0; \n      clonedHand.builtCardsThisPlayerTurn= 0;      \n      clonedHand.coinsOrCardsThisTurn = false;\n      clonedHand.characterActThisTurn = false;\n      clonedHand.canMoveNext= {}; // when it will be possible it will become { can: true, must: true/false }\n      clonedHand.districtsBuiltThisPlayerCharacter= 0;\n      clonedHand.messages= {};\n\n      setHand(clonedHand); // doenst trigger event\n    },\n\n    // @MODEL:APP game - changes the stage to the next.\n    moveToNextStage: () => {\n      logfn( 'moveToNextStage from', hand.stage);\n      let nextStage = null;\n      const keys = Object.keys(stages);      \n      if (hand.stage)\n        keys.forEach( ( stageName, i) => {\n          if ( stageName === hand.stage) { // found current stage\n              // assign the next stage\n              if (i === (keys.length - 1)) {\n                nextStage = 'discard-character';  // when finished the stages (call-character-8) we start over\n              } else {              \n                nextStage = keys[i + 1];  // NEXT stage\n              }\n            }\n          });\n      else {\n        nextStage = keys[0]; \n      }\n      setHand(Object.assign(clonedHand, {stage: nextStage})); \n      //->>>> hand.stage change triggers\n    },\n\n    setMessage: ( key, jsx ) => {\n      if (!clonedHand.messages) return;\n      if (clonedHand.messages[key]) clonedHand.messages[key] = null;\n      clonedHand.messages[key] = [clonedHand.messages[key], jsx];\n      setHand(clonedHand);\n    },\n\n    // @MODEL:APP game - when the turn is finished and we move fw (this fn knows if we move to next player or next stage)\n    moveToNextPlayerOrStage: () => {\n        const { loopPlayers } = gameAPI.getCurrentStageParams();\n\n        let moveStage = !loopPlayers;\n        logfn( 'moveToNextPlayerOrStage', `moveStage ${moveStage}, loopPlayers ${loopPlayers}` );\n        \n        if (loopPlayers) {\n          let nextPlayer = currentPlayer + 1;\n          if (nextPlayer === players.length) {\n            logg('Turned around all players. Next stage, please! ');\n            nextPlayer = null;\n            moveStage = true;\n          } \n          setCurrentPlayer(nextPlayer); //->>>> currentPlayer change trigger (resets hand params)\n        }\n\n        if (moveStage) {\n          gameAPI.moveToNextStage(); // triggers hand.stage\n        }\n\n    },\n    \n    // @MODEL:APP game - sees if the conditions of the game (in hand) are fulfilled with the requirements of the stage.\n    // we check it when we pick up a card, we build a district, take an action(money or card), and character acts.\n    checkMoveToNextPlayerOrStage: ( only_return_true_or_false = false ) => {\n\n      if (! hand.stage ) return false;\n      logfn( 'checkMoveToNextPlayerOrStage', `force action ${!only_return_true_or_false}` );\n\n      let canMove = true; // init. Will tell if the turn can finish or not (allowed to pass turn)\n      let shouldMove = false; // init. Will tell if the turn is finished completly so we force moving (for the case when the user can build and has to decide)\n      const {minCardsToPickup, mustChooseCoinsOrCards, characterAct } = gameAPI.getCurrentStageParams(); // object\n\n      // situation: character X (ie the assasin) is called and no player has the card.\n      // if (characterAct && (currentPlayer === null)) {\n      //   setHand(Object.assign( clonedHand, { canMoveNext: { can: true, must: true } } ));\n      //   return { allowedToMove: true, forcedToMove: true };\n      // }\n\n      // we check options that makes us decide that the player can not move to the next step yet\n      canMove = canMove && !(minCardsToPickup &&  clonedHand.pickedCardsThisPlayerTurn < minCardsToPickup);\n      canMove = canMove && !( mustChooseCoinsOrCards && !clonedHand.coinsOrCardsThisTurn ); // it means that action was not taken yet and it should.\n      canMove = canMove && !( (characterAct === 'mandatory' || characterAct === 'automatic') && ( !clonedHand.characterActThisTurn ) );\n      \n      // has the possibility of building?\n      // the reason that can hold the player from passing turn is that he can build.\n      if (canMove && ( !playersAPI.playerCanBuild() ) ) {\n        shouldMove = true;\n      }\n\n      // only informative option\n      if (only_return_true_or_false) {        \n        setHand(Object.assign( clonedHand, { canMoveNext: { can: canMove, must: shouldMove } } ));\n        return { allowedToMove: canMove, forcedToMove: shouldMove };\n      }\n\n      // normally this is the action. AT THE MOMENT THIS NEVER EXECTURES\n      if (shouldMove) {\n          gameAPI.moveToNextPlayerOrStage();        \n      }\n    },\n\n    // MODEL:APP game\n    getCurrentStageParams: () => {\n      if (clonedHand && clonedHand.stageParamsThisTurn)\n        return clonedHand.stageParamsThisTurn;\n      return {};\n    },\n\n    // @MODEL:APP game.\n    setUpCharacterSettings: (characterNumber) => {\n      logfn( 'setUpCharacterSettings', characterNumber);  \n      const { playerIndex, card } = playersAPI.getPlayerWhoOwnsCharacterCard(characterNumber);\n\n      setCurrentPlayer(playerIndex);\n\n      // @MAYBECHANGE: any action related to characters set in currentPlayer UPDATE could come here for uniformity.\n      \n      // if current character is killed there is no action he can make.\n      if (card.is_killed || playerIndex === null) {          \n        clonedHand.stageParamsThisTurn.mustChooseCoinsOrCards = false;\n        clonedHand.stageParamsThisTurn.characterAct = false;\n        clonedHand.stageParamsThisTurn.maxCardsToPickup = 0;\n        clonedHand.stageParamsThisTurn.allowedToBuild = 0;\n        gameAPI.setMessage('before_coins_or_cards_btn', card.is_killed? (<p>You are DEAD!</p>) : (<p>Nooo one</p>));\n        gameAPI.checkMoveToNextPlayerOrStage( true );\n        setHand(clonedHand);\n        return;          \n      }\n\n      // We call the card The King and move current Player to the payer that will get the crown.\n      if (hand.stage === 'call-character-4') {        \n        const { playerIndex : kingPlayerIndex } = playersAPI.getPlayerWhoOwnsCharacterCard(4); // currentPlayer is still not defined. So we take the new crown Owner from this\n        setCrownPlayer(kingPlayerIndex);\n        logg('@ACTION OF POWER for character 4 - The King. Get the crown: '+players[kingPlayerIndex].name);\n        setHand( Object.assign( clonedHand, { characterActThisTurn: 'get-the-crown'} ) );\n        gameAPI.setMessage('before_coins_or_cards_btn', <p>You got the crown, as the king that you are</p>);\n        // TODOMESSAGE\n      }\n\n      // \n      if (card.is_stolen) {\n        // al money goes to the player with character 2.\n        const { playerIndex: characted2PlayerIndex } = playersAPI.getPlayerWhoOwnsCharacterCard(2);\n        const clonedPlayers = [ ...players ];\n        clonedPlayers[characted2PlayerIndex].money += clonedPlayers[playerIndex].money;\n        clonedPlayers[playerIndex].money = 0;\n        gameAPI.setMessage('before_coins_or_cards_btn', <p>You have been stolen by the Thief!, owned by <b>{ players[characted2PlayerIndex].name }</b></p>);        \n        setPlayers(clonedPlayers);\n      }\n\n      // 4 characters receive gold by the cards on his ditrict: charNum 4, 5, 6, 8.\n      // we take the district cards from this player that are built and belong to this character\n      if ([4,5,6,8].includes(card['character-number'])) {\n        playersAPI.payPlayerByDistrictCardsType(playerIndex, card['character-number']);\n      }\n    }\n  \n\n  } // end gameAPI\n\n  /*  C A R D S     A.P.I      starts\n                 ██████████       \n                ████████████      \n                ██        ██      \n                ██▄▄▄▄▄▄▄▄▄█      \n                ██▀███ ███▀█      \n  █             ▀█        █▀      \n  ██                  █           \n   █              ██              \n  █▄            ████ ██  ████\n   ▄███████████████  ██  ██████   \n      █████████████  ██  █████████\n               ████  ██ █████  ███\n                ███  ██ █████  ███\n                ███     █████████ */\n  \n    const cardsAPI = {\n    // @MODEL:CARDS - INIT\n    // grab the cards from json file and load them into \n    loadCards: async () => {\n      logfn( 'loadCards', [...arguments ]);\n      // Change this in the future if we want to load different cards from an API\n      const url = window.location.origin + '/cardsdemo.json';\n      // var json = require(url); //(with path)\n      console.log(url);\n      await fetch(url)\n        .then(response => response.json())\n        .then(json => {\n          console.log(json);\n          json.forEach(card => {\n            if (card[\"repeat-card\"]) {\n              // in the file, if the card has the field repeat-card, we clone that card that amount of times.\n              const repeatTimes = card[\"repeat-card\"];\n              delete card[\"repeat-card\"];\n              for ( let i =1; i < repeatTimes; i++) {\n                let newCard = Object.assign({}, card);\n                newCard.ID = card.ID + '.'+i; // new ID is '104.1' for example\n                json.push(newCard);\n              }\n            }\n          });\n          setCards([...json]);\n        });\n\n      // or whatever you want to do with the resulting object\n    },\n\n    // @MODEL:CARDS\n    getCardIndexByID: cardID => cards.findIndex( card => card.ID === cardID ),\n    getCardByID: cardID => cards[cardsAPI.getCardIndexByID(cardID)],\n    getCardIndexByCharacterNumber: characterNumber => cards.findIndex( card => (card['character-number'] && card['character-number'] === characterNumber) ),\n    getCardByCharacterNumber: characterNumber => cards[cardsAPI.getCardIndexByCharacterNumber(characterNumber)],\n    getCalledCharacterCard: () => {\n        if (!hand || !hand.stage) return {};\n        if (!hand.stage.includes('call-character-')) return {};\n        const characterNumber = parseInt(hand.stage.slice(hand.stage.lastIndexOf('-') + 1)); // grabs 3 from 'call-character-3' \n        return cardsAPI.getCardByCharacterNumber(characterNumber);\n    },\n\n\n    // @MODEL:CARDS - get, from the whole deck, only the 'typeOfCard' (character/district) cards and shuffle them. Ready to be taken by players\n    // @param typeOfCard: 'character' cards, 'district' cards or all?\n    // @param shuffleBool: do we shuffle the created deck?\n    initDistrictOrCharacterDeck: (typeOfCard = null, shuffleBool = false) => {\n      logfn( 'initDistrictOrCharacterDeck', typeOfCard );\n      // 1) get, from Cards, only the type \"character\" or \"disctrict\" cards in an array.\n      let deck = [...cards ];\n      console.log('cards character not shuffled:', cards);\n      if (typeOfCard) {\n      deck = deck.filter(card => card.type && card.type === typeOfCard);\n      }\n      \n      // 2) shuffle it (using helper fn)\n      if (shuffleBool)\n        deck = shuffle(deck);\n\n      // Update the state of the list of cards\n      console.log(`deck of ${typeOfCard} shuffled and initialized as `, deck); \n      if (typeOfCard === 'character') \n        setCharacterCards(deck);\n      else if (typeOfCard === 'district')\n        setDistrictCards(deck);\n\n      return deck; // just in case, but normally we wont need it\n    },\n\n    // @MODEL:CARDS - \n    buildCard: (cardID) => {\n      let all_cards = [...cards];\n      let all_players = [...players];\n      const cardIndex = cardsAPI.getCardIndexByID(cardID);\n      const { playerIndex } = playersAPI.getPlayerWhoOwnsDistrictCard(cardID);\n      logfn( 'buildCard', cards[cardIndex].name );\n      \n      // VALIDATION\n      if (!gameAPI.getCurrentStageParams().allowedToBuild) {\n        console.log('this stage is not for building');\n        return;\n      }\n      if (hand.builtCardsThisPlayerTurn >= gameAPI.getCurrentStageParams().allowedToBuild) {\n        console.log('you already built enough');\n        return;\n      }\n      if (playerIndex !== currentPlayer) {\n        console.log('You can\\'t buy cards if you are not the current player');\n        return;\n      }\n      if (players[playerIndex].money < cards[cardIndex].price) {\n        alert(`Sorry, this card costs $${cards[cardIndex].price} and you only have ${players[playerIndex].money}!`);\n        return null; // the player doesnt have money to build that card\n      }\n\n      // remove money form player!\n      all_players[playerIndex].money -= cards[cardIndex].price;\n      setPlayers(all_players);\n\n      if ( typeof cardIndex === 'number' ) {\n        all_cards[cardIndex].is_built = true;\n        setCards(all_cards);\n\n        setHand(Object.assign( clonedHand, { builtCardsThisPlayerTurn : clonedHand.builtCardsThisPlayerTurn + 1 }) ); \n        //->>>> we didnt define trigger State Event hand.builtCardsThisPlayerTurn\n        \n        gameAPI.checkMoveToNextPlayerOrStage(true);\n        \n      }\n    },\n\n    // @MODEL:CARDS - updates the given card as 'killed'\n    killCharacter: (character_number) => {\n      logg('@ACTION OF POWER for character 1 - kill', character_number);\n      let all_cards = [...cards];\n      const theCardToKillIndex = cardsAPI.getCardIndexByCharacterNumber(character_number);\n      if ( typeof theCardToKillIndex === 'number' && theCardToKillIndex >= 0 ) {\n        all_cards[theCardToKillIndex].is_killed = true;\n        clonedHand.characterActThisTurn = 'kill';\n        gameAPI.setMessage('after_character_acts', (<h3>You killed {all_cards[theCardToKillIndex].name}!</h3>));\n        setCards(all_cards);\n        setHand(clonedHand);        \n        return;\n      }\n    },\n\n    // @MODEL:CARDS - updates the given card as 'stolen'\n    stealCharacter: (character_number) => {\n      logg('@ACTION OF POWER for character 2 - steal another card');\n      let all_cards = [...cards];\n      const theCardToStealIndex = cardsAPI.getCardIndexByCharacterNumber(character_number);\n      if ( typeof theCardToStealIndex === 'number' && theCardToStealIndex >= 0 ) {        \n        all_cards[theCardToStealIndex].is_stolen = true;\n        setCards(all_cards);\n        gameAPI.setMessage('after_character_acts', (<h3>You stole from {all_cards[theCardToStealIndex].name}!</h3>));\n        clonedHand.characterActThisTurn = 'steal';\n        setHand(clonedHand);\n        // TODOMESSAGE\n        return;\n      }\n    },\n\n  } // end cardsAPI\n    \n\n//                                P L A Y E R S \n//                                 __________\n//                               /           \\\n//                               |   0 . 0    |\n//                               |    /_      P\n//                               \\_   ___     /\n//                                 \\________/\n//                                  A. P. I.\n\n  const playersAPI = {\n\n\n    // @MODEL:PLAYER/CARDS\n    // WHAT: removes the card from the specified deck, and returns it\n    // ...\n    // @param playerIndex\n    // @param cardID: the ID of the card in the array cards. If null it takes random, if 'last-district-card' it takes the last\n    // @param times: number of cards to pick up, used when cardID : 'last-district-card'\n    // Status update: [..]\n    pickUpCard: ( { playerIndex= null, cardID = null, times= 1 } ) => {\n            \n      // 0 ) VALIDATION: get number of cards per turn, and check that we are ok\n      if (clonedHand.pickedCardsThisPlayerTurn >= gameAPI.getCurrentStageParams().maxCardsToPickup) {\n        console.log('Tried to pick up more cards than allowed');\n        return;\n      }\n\n      // 1) DATA: init the player and the card. If not player set, get current. If not card set, random.\n      let deck, grabLastDistrictCard;\n      \n      if (typeof(cardID) === 'number') {\n        const cardType = cardsAPI.getCardByID(cardID);\n        deck = (cardType === 'district') ? [...districtCards] : [...characterCards];\n        times = 1; // just to make sure we run it exactly 1 loop.\n      } else {\n        deck = [...districtCards];\n        grabLastDistrictCard = (cardID === 'last-district-card');\n      }\n      const thePlayerIndex = playerIndex || currentPlayer;\n      let playersUpdated = [...players];\n      let cardIndex, theCard;\n\n      logfn( `pickUpCard`, `ID ${cardID} by player ${playerIndex}` );\n      \n      if (!deck.length) {\n        logg('--- deck empty. exit');\n        return;\n      }\n\n\n      // WE TAKE times CARDS FROM THE DECK\n      \n      for (let i=0; i<times; i++) {\n\n        if (grabLastDistrictCard) {\n          if ( deck.length <= 0 ) {\n            logg('There are no more district cards. Total grabbed so far: ' +clonedHand.pickedCardsThisPlayerTurn);\n            cardID = null; // we dont do actions on the deck\n          } else {\n            cardID = deck[deck.length - 1].ID;\n          }\n        } \n\n        if (cardID) {\n          cardIndex = cardID ? cardsAPI.getCardIndexByID(cardID) : Math.floor(Math.random() * cards.length);\n          theCard = cards[cardIndex];\n                \n          // console.log(`Picking up card ${theCard.name} from ${theCard.type}, by player ${thePlayerIndex}`);\n        \n          // 2) @MODEL:CARDS Remove the card from deck. \n          deck.splice(deck.findIndex(card => card.ID === cardID), 1); // deck has one less item now\n          // Update the right deck (characters or district).  \n          \n          // 3) @MODEL:PLAYERS: include that card in the list of cards of that player.        \n          const thePlayer = Object.assign({}, playersUpdated[thePlayerIndex]);\n          thePlayer[`${theCard.type}Cards`].push(cardIndex); // ie. players[3].characterCards = [  3, 0, 1, 9] Where 9 is the index in array cards of the current card.\n          thePlayer[`${theCard.type}Cards`] = thePlayer[`${theCard.type}Cards`].filter(unique);\n          playersUpdated[thePlayerIndex] = thePlayer;\n          \n          // update param value.\n          clonedHand.pickedCardsThisPlayerTurn = clonedHand.pickedCardsThisPlayerTurn+1;\n          logg(`-- card grabbed ${theCard.name}, by ${players[thePlayerIndex].name}. Total ${clonedHand.pickedCardsThisPlayerTurn}`);\n        } \n      }  \n        \n      // setState calls\n      if (theCard) \n        if (theCard.type === 'character') setCharacterCards(deck); else setDistrictCards(deck);\n      setPlayers(playersUpdated);\n      setHand(Object.assign(clonedHand)); \n      //->>>> trigger State Event hand.pickedCardsThisPlayerTurn change\n        \n        \n    },\n\n    // returns bool\n    playerHasCharacter: ( plyrIndx, character_number) => {\n      logfn( `playerHasCharacter`, plyrIndx, character_number);\n      const { playerIndex: playerIndexWithCharacter } = playersAPI.getPlayerWhoOwnsCharacterCard(character_number);\n      return playerIndexWithCharacter === plyrIndx;\n    },\n\n    // @MODEL:PLAYERS [...]\n    getPlayerWhoOwnsCharacterCard: (character_number) => {\n      logfn( `getPlayerWhoOwnsCharacterCard`, character_number);\n      \n      const cardIndex = cardsAPI.getCardIndexByCharacterNumber(character_number);\n      let playerIndex = players.findIndex( player => player.characterCards.includes(cardIndex) );       \n      const player = (typeof playerIndex === 'number')? players[playerIndex] : {};\n      return { player, playerIndex: (playerIndex>=0? playerIndex : null), card: cards[cardIndex], cardIndex };\n    },\n    \n    getPlayerWhoOwnsDistrictCard: (cardID) => {\n      logfn( `getPlayerWhoOwnsCard`, cardID);\n      const cardIndex = cardsAPI.getCardIndexByID(cardID);\n      const playerIndex = players.findIndex( player => player.districtCards.includes(cardIndex) );\n      const player = players[playerIndex];\n      return { player, playerIndex, card: cards[cardIndex], cardIndex };\n    },\n\n    // @MODEL:PLAYERS\n    giveMoneyToPlayer: (coins = 0, playerIndex = null) => {\n      const playrIndx = (playerIndex === null) ? currentPlayer : playerIndex;\n      logfn( `giveMoneyToPlayer`, playrIndx + ' +' + coins);\n      if ( playrIndx === null ) return;\n      const playersTemp = [ ...players ];\n      playersTemp[playrIndx].money = playersTemp[playrIndx].money + coins;\n      setPlayers(playersTemp);  // doesnt trigger anything\n    },\n\n    // increases the .money of the player and updates the hand param 'districtsBuiltThisPlayerCharacter'.\n    payPlayerByDistrictCardsType: ( plIndx, districtType ) => {\n      \n      const districtCardsForThisCharacter = playersAPI.getBuildDistrictCardsForPlayerAndType(plIndx, districtType)\n          // for ( let cardIndx of districtCardsForThisCharacter ) {\n      if (districtCardsForThisCharacter.length) {        \n        playersAPI.giveMoneyToPlayer(districtCardsForThisCharacter.length, plIndx);\n        gameAPI.setMessage('before_coins_or_cards_btn', <p>You have received $ {districtCardsForThisCharacter.length} because you have the card {cardsAPI.getCalledCharacterCard().name} and {districtCardsForThisCharacter.length} built cards for this character</p>);\n        setHand(clonedHand, { districtsBuiltThisPlayerCharacter: districtCardsForThisCharacter.length });\n        logg('----hand.districtsBuiltThisPlayerCharacter: '+districtCardsForThisCharacter.length);\n      }\n\n    },\n\n    setPlayerWithCrownFirst: () => {      \n      // ie: [Peter, Mark, John*, Susanne] we convert it into [John*, Susanne, Peter, Mark]\n      logfn( `setPlayerWithCrownFirst ${players[crownPlayer]? players[crownPlayer].name : ''}` );\n      if (crownPlayer !== null) {\n        let playersPrev = [...players].slice(crownPlayer).concat([...players].slice(0, crownPlayer));\n        setPlayers(playersPrev);\n        setCrownPlayer(0);\n        return playersPrev; // just in case we want to use the modified array form the caller fn\n      }\n      return players;\n    },\n\n    // does the player have money to build any of his district cards?\n    // @return false if the player can't build at all\n    playerCanBuild: ( playerIndex, cardIndex = null) => {\n      const { allowedToBuild } = gameAPI.getCurrentStageParams();\n      \n      if ( typeof playerIndex !== 'number' || ( playerIndex !== currentPlayer )) return false; // only current player can build\n      if ( !allowedToBuild ) return false; // in the stage doesnt allow to build return false.\n      \n      const playrIndx = (playerIndex === null) ? currentPlayer : playerIndex;\n      \n      if ( allowedToBuild <= clonedHand.builtCardsThisPlayerTurn ) return false; // already built enough! \n\n      const playerBuildableDictrictCards = [ ...players[playrIndx].districtCards ]  // from the district cards\n            .filter( cardIndex => {                         \n              const have_money = cards[cardIndex].price <= players[playrIndx].money; // only the affordable\n              return have_money && (!cards[cardIndex].is_build); // and only the non built ones.\n            } );      \n      logg(`calculing buildable cards of ${players[playerIndex]? players[playerIndex].name : '++' + playerIndex + '!!!' }: `, playerBuildableDictrictCards);\n\n      if (cardIndex === null) // can build in general?\n        return playerBuildableDictrictCards.length ? playerBuildableDictrictCards : false;\n      else {\n        // can build THAT card?\n        if (!playerBuildableDictrictCards.length) return false;\n        return playerBuildableDictrictCards.includes(cardIndex); // if the card is included in the buildable cards, why not?\n      }\n    },\n\n    // @MODEL:PLAYERS - act for the magician (dependiente tienda comics)\n    swapDistrictCardsBetweenPlayers: ( player1Index = null, player2Index) => {\n      \n      const thePlayer1Index = player1Index || currentPlayer;\n      logfn( `swapDistrictCardsBetweenPlayers ${thePlayer1Index}`, player2Index);\n\n      // proceed to the swap of variables. We only swap the non built cards!\n      let tempPlayers = [ ...players ];\n      const tempPlayer1DistrictCards = [...players[thePlayer1Index].districtCards ];\n      tempPlayers[thePlayer1Index].districtCards = tempPlayer1DistrictCards.filter( ci => cards[ci].is_built ).concat( [ ...players[player2Index].districtCards.filter( ci => !cards[ci].is_built ) ] );\n      tempPlayers[player2Index].districtCards = [...players[player2Index].districtCards ].filter( ci => cards[ci].is_built ).concat( tempPlayer1DistrictCards.filter( ci => !cards[ci].is_built ) );\n      setPlayers(tempPlayers);\n\n      logg('@ACTION OF POWER for character 3: Magician - swap non built district cards with other player');\n      setHand(Object.assign(clonedHand, { characterActThisTurn: 'swap-cards' }));\n      gameAPI.setMessage('after_character_acts', (<h3>Your hand cards have been replaced with {players[player2Index].name} </h3>));\n    },\n\n    // @MODEL:PLAYERS/CARDS\n    destroyBuiltCardByWarlord: (card) => {\n      const { player : playerDestroyed, \n              playerIndex : playerIndexDestroyed, \n              cardIndex : cardIndexDestroyed } = playersAPI.getPlayerWhoOwnsDistrictCard(card.ID); // info about the destroyed card and its owner\n      \n      const currentCalledCard = cardsAPI.getCalledCharacterCard();\n      const { playerIndex: warlordPlayerIndex } = playersAPI.getPlayerWhoOwnsCharacterCard(8);\n      \n      logfn( `destroyBuiltCardByWarlord ${card.name}`, warlordPlayerIndex);\n\n      // VALIDATION\n      // TODO: the card can't be destroyed if the owner has the character Home (5)\n      if (playersAPI.playerHasCharacter(playerIndexDestroyed, 5)) {\n        console.log(`The card ${card.name} can't be destroyed. Its owner has the Bishop!`);\n        return false;\n      }\n      // TODO: the card can't be destroyed if it belongs to a complete district or a district with the Tower.\n      // TODO: only if it's build, it can be removed.\n      if (!card.is_built) {\n        console.log(`The card ${card.name} can't be destroyed. It is not built!`);\n        return false;\n      }\n      // only if the current player is Bart, and has money, it can be removed.\n      if (currentCalledCard['character-number'] !== 8) {\n        console.log(`The current character is not the Warlord, who is the only one allowed to destroy`);\n        return false;\n      }\n      if ( !(players[warlordPlayerIndex].money >= (card.price - 1 ))) {\n        console.log(`The current player doesnt have money to destroy that card, which costs ${(card.price - 1 )}`);\n        return false;\n      }\n      \n      if (!playersAPI.playerHasCharacter(currentPlayer, 8)) {\n        console.log(`The current Player hasnt the Warlord card. He cant destry any card.`);\n        return false;\n      }\n\n      \n      // remove card from player.\n      const indexInPlayersCards = playerDestroyed.districtCards.findIndex( index => cards[index].ID === card.ID );\n      if (!indexInPlayersCards) return false;\n      let newPlayers = [ ...players];\n      let distritCardsAfterDestroy = [ ...newPlayers[playerIndexDestroyed].districtCards ];\n      distritCardsAfterDestroy.splice(indexInPlayersCards, 1);\n      newPlayers[playerIndexDestroyed].districtCards = distritCardsAfterDestroy;      \n\n      // remove money from Barts player - This could be and should be currentPlayer \n      newPlayers[warlordPlayerIndex].money = newPlayers[warlordPlayerIndex].money - (card.price - 1);\n\n      setPlayers( newPlayers ); // the card has dissappeared for the player and the money from the current player\n\n      // change the param is_built to false\n      let newCard = Object.assign( { ...cards[cardIndexDestroyed] }, { is_built: false } );\n      let newCards = [ ...cards ];\n      newCards[cardIndexDestroyed] = newCard;\n      setCards( newCards ); // the card is not built anymore\n\n      // add it to the beggining of the deck \n      let tempDistrictCards = [...districtCards];\n      tempDistrictCards = [card].concat(tempDistrictCards); // this is the new districtCards deck\n      setDistrictCards(tempDistrictCards); // put the cards on the beginning\n\n      gameAPI.setMessage('after_character_acts', <p>You have destroyed the card {card.name} to player {players[playerIndexDestroyed].name} </p> );        \n\n      return true; // everything went ok, the card is destroyed.\n    },\n\n    getBuildDistrictCardsForPlayer: (playerIndex) => {\n      if ( typeof playerIndex !== 'number' ) return [];\n      let dCards = [...players[playerIndex].districtCards]; // array of cards index.\n      return dCards.filter( cardIndx => cards[cardIndx].is_built );\n    },\n\n    getBuildDistrictCardsForPlayerAndType: (plyrIndx, districtType) => {       \n      if ( typeof plyrIndx !== 'number' ) return [];\n      return playersAPI.getBuildDistrictCardsForPlayer(plyrIndx).filter(\n        cardIndx => cards[cardIndx][\"type-of-district\"] === districtType\n      );\n    }\n\n  } // end playersAPI\n\n\n  // END OF C O N T R O L L E R ++++++++++++++++++++++++++++++++++++++++\n\n\n  \n  // *** L I F E  C Y C L E (@MODEL:APP GAME; actions on states update) *******************\n  // *************************************************************\n \n\n/*\n        @@@@@@           @@@@@@\n      @@@@@@@@@@       @@@@@@@@@@\n    @@@@@@@@@@@@@@   @@@@@@@@@@@@@@\n  @@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@\n @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n      @@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@\n          @@@@@@@@@@@@@@@@@@@\n            @@@@@@@@@@@@@@@\n              @@@@@@@@@@@\n                @@@@@@@\n                  @@@\n                   @\n\n*/\n\n  // ONUPDATE currentPlayer (change of turn)------\n  const prevCurrentPlayer = usePrevious(currentPlayer);\n  useEffect(() => {\n    // Only if currentPlayer changes from a player to the next one:\n    if ( prevCurrentPlayer ===  currentPlayer) return;\n    logfn('currentPlayer UPDATE', prevCurrentPlayer, currentPlayer);\n    \n    if (gameAPI.getCurrentStageParams().loopPlayers)\n      gameAPI.resetHandParams();\n\n    // If we are in the stage of picking up district cards, the player takes 2 coins on the beginning.\n    if (hand.stage === 'district-selection') {\n      let giveTurnMoney = true;\n      giveTurnMoney = giveTurnMoney && !cardsAPI.getCalledCharacterCard().is_killed;\n      if (giveTurnMoney) {\n        playersAPI.giveMoneyToPlayer(2);\n        // clonedHand.messages = Object.assign({...clonedHand.messages}, { after_coins_or_cards_btn: <p>You won't be payed this turn ... :(</p> });\n      }\n      else {\n        gameAPI.setMessage('after_coins_or_cards_btn', <p>You won't be payed this turn ... :(</p> );        \n      }\n      setHand( clonedHand );        \n    }\n\n    // Sett more actions at setupCharacteer\n  }, [prevCurrentPlayer, currentPlayer, gameAPI, hand.stage, playersAPI, hand, clonedHand, cardsAPI]);\n\n\n  // ONUPDATE hand.pickedCardsThisPlayerTurn ------ every time a player picks a card from district or char deck (or the system discards a card from the char deck)\n  const prevPickedCardsThisPlayerTurn = usePrevious(hand.pickedCardsThisPlayerTurn);\n  useEffect(() => {\n    // Only if hand.pickedCardsThisPlayerTurn changes and we don't consider that the param is reset to 0:\n    if ( prevPickedCardsThisPlayerTurn ===  hand.pickedCardsThisPlayerTurn) return;\n    if ( !hand.pickedCardsThisPlayerTurn) return;\n\n    logfn('hand.pickedCardsThisPlayerTurn UPDATE', prevPickedCardsThisPlayerTurn, hand.pickedCardsThisPlayerTurn);\n\n    // depending on the stage, we see what's the limit.\n    \n    gameAPI.checkMoveToNextPlayerOrStage(true);\n\n  });\n\n\n  // ONUPDATE hand.characterActThisTurn ------ when a cahracter played his powe (kill, steal ...)\n  const prevCharacterActThisTurn = usePrevious(hand.characterActThisTurn);\n  useEffect(() => {\n    // Only if hand.characterActThisTurn changes and we don't consider that the param is reset to 0:\n    if ( prevCharacterActThisTurn ===  hand.characterActThisTurn) return;\n    if ( !hand.characterActThisTurn) return;\n\n    gameAPI.checkMoveToNextPlayerOrStage(true);\n\n    logfn('hand.characterActThisTurn UPDATE', prevCharacterActThisTurn, hand.characterActThisTurn);\n  });\n  \n  // ONUPDATE hand.coinsOrCardsThisTurn ------ when a player took the action ( money or cards ). ie, Mr burns receives 1 gold after action\n  const prevcoinsOrCardsThisTurn = usePrevious(hand.coinsOrCardsThisTurn);\n  useEffect(() => {\n    // Only if hand.coinsOrCardsThisTurn changes and we don't consider that the param is reset to 0:\n    if ( prevcoinsOrCardsThisTurn ===  hand.coinsOrCardsThisTurn) return;\n    if ( !hand.coinsOrCardsThisTurn) return;\n    \n    logfn(`hand.coinsOrCardsThisTurn UPDATE from ${prevcoinsOrCardsThisTurn} to ${hand.coinsOrCardsThisTurn}, stage ${hand.stage}`);\n\n    if (hand.stage === 'call-character-6') {\n      logg('@ACTION OF POWER for character 6 - on Update coinsOrCards, receives 1$ after choosing money/cards (Mr Burns).');\n      clonedHand.characterActThisTurn = 'collect-tax';\n      gameAPI.setMessage('after_coins_or_cards_action', <p>Merchant: You have received $ 1!!</p> );      \n      setHand( clonedHand );\n\n      playersAPI.giveMoneyToPlayer(1);\n    }\n    \n    if (hand.stage === 'call-character-7') {\n      playersAPI.pickUpCard( { cardID: 'last-district-card', times:2 } );\n      gameAPI.setMessage('after_coins_or_cards_action', <p>You receive 2 aditional cards, {} in total</p> );      \n      setHand( Object.assign(clonedHand, { characterActThisTurn: 'receive-extra-cards'} ) );\n      logg('@ACTION OF POWER for CHARACTER 7 - on Update coinsOrCards (Architect -Lenny&Carl) receives 2 district cards');\n    }\n\n\n    gameAPI.checkMoveToNextPlayerOrStage(true);\n\n  }, [prevcoinsOrCardsThisTurn, hand, gameAPI, playersAPI, clonedHand]);\n\n// ONUPDATE hand.canMoveNext ------ changes when an action lets the player to pass turn. this is updated by other states in the lifecycle\nconst prevCanMoveNext = usePrevious(hand.canMoveNext);\nuseEffect(() => {\n  // Only if hand.canMoveNext changes and we don't consider that the param is reset to 0:\n  if ( prevCanMoveNext ===  hand.canMoveNext) return;\n  if ( !hand.canMoveNext ) return;\n  if ( isEmpty(hand.canMoveNext) ) return; // we dont consider the param when reset\n\n  // if we get here, we moved into 'can move to next turn'\n\n  // automatically move to the next stage without more waiting.\n  if  (hand.canMoveNext.can && hand.canMoveNext.must) {\n    if ( ['district-selection', 'discard-character', 'character-selection-1', 'character-selection-2' ]\n                                      .includes(hand.stage) )\n      gameAPI.moveToNextPlayerOrStage();\n  }\n  \n\n  logfn(`hand.canMoveNext UPDATE from ${prevCanMoveNext} to ${hand.canMoveNext}, stage ${hand.stage}`);\n});\n\n\n\n\n  // ---- THE REAL LIFE CYCLE OF THE GAME - events on every stage -----------------------------\n  const prevStage = usePrevious(hand.stage);\n  // ONUPDATE hand.stage--------------------------\n  useEffect(() => {\n    // Only if hand.stage changes:\n    if ( prevStage ===  hand.stage) return;\n    logfn('hand.stage UPDATE', prevStage, hand.stage);\n\n    // inits everytime we move to next stage.\n    gameAPI.resetHandParams();\n\n    let playersX = [...players]; // cloning for updating.    \n    const { loopPlayers } = gameAPI.getCurrentStageParams(); \n\n    setCurrentPlayer( (loopPlayers)? 0 : null) ; // init currentPlayer, if it is a turn of players\n\n    // @MAYBECHANGE: I could just use if getCurrentStageOptions().characterAct to apply setUpCharacterSettings and avoud the switch\n\n\n    switch (hand.stage) {\n\n      case 'district-selection':\n          // now the actions are triggered by the selection of the cards by clickin on it.\n        break;\n\n      case 'discard-character':\n        // reset character cards for every player\n        playersX = playersAPI.setPlayerWithCrownFirst();\n        playersX.map( (player, i) => { \n          playersX[i].characterCards = [];\n        });\n        setPlayers(playersX);\n        const newCards = [...cards].map( c => Object.assign(c, { is_killed: false, is_stolen: false}) );\n        setCards(newCards); // reset cards properties changes in the previous turn.\n        cardsAPI.initDistrictOrCharacterDeck('character');\n        // from here CardsDeck > clicking in a char card triggers the picked card\n        break;\n      case 'character-selection-1' :\n        break;\n      case 'character-selection-2' : \n        break;\n      case 'call-character-1' :\n        // ACTION of char 1: THE ASSASSIN.\n        gameAPI.setUpCharacterSettings(1);        \n        break;\n      case 'call-character-2' :\n        // ACTION of char 2: THE THIEF.\n        gameAPI.setUpCharacterSettings(2);\n        break;\n      case 'call-character-3' :\n        // ACTION of char 3: THE MAGICIAN.\n        gameAPI.setUpCharacterSettings(3);\n        break; \n      case 'call-character-4' :\n        // ACTION of char 4: THE KING.\n        \n        gameAPI.setUpCharacterSettings(4);        \n        \n        break;\n      case 'call-character-5' :\n        // ACTION of char 5: THE BISHOP - cant be destroyed.\n        gameAPI.setUpCharacterSettings(5);\n        break;\n      case 'call-character-6' :\n        // ACTION of char 5: THE MERCHANT (Mr burns)- after action, takes 1 gold more. See update hand.coinsOrCardsThisTurn\n        gameAPI.setUpCharacterSettings(6); // See hand.coinsOrCardsThisTurn UPDATE - it will receive a coin when that triggers\n        break;\n      case 'call-character-7' :\n        gameAPI.setUpCharacterSettings(7);\n        break;\n      case 'call-character-8' :\n        gameAPI.setUpCharacterSettings(8);\n        break;\n\n      default:\n        break;\n    }\n\n\n    return () => {\n\n    }\n  }, [prevStage, hand.stage, crownPlayer, playersAPI, players, gameAPI, cardsAPI, currentPlayer, cards])\n\n  // *** end of LIFE CYCLE  **************************************\n  // *************************************************************\n \n\n\n/* ++++++++++++++++++++++++++++++++ V I E W ++++++++++++++++++++++++++++++++\n  /~~~\\/~~\\/~~~\\/~~~\\/~~\\/~~~\\                    /~~~\\/~~\\/~~~\\/~~~\\/~~\\/~~~\\\n  | /\\/ /\\/ /\\ || /\\/ /\\/ /\\ |                    | /\\ \\/\\ \\/\\ || /\\ \\/\\ \\/\\ |\n  \\ \\/ /\\/ /\\/ /\\ \\/ /\\/ /\\/ /                    \\ \\/\\ \\/\\ \\/ /\\ \\/\\ \\/\\ \\/ /\n   \\ \\/\\ \\/\\ \\/  \\ \\/\\ \\/\\ \\/                      \\/ /\\/ /\\/ /  \\/ /\\/ /\\/ /\n ,_/\\ \\/\\ \\/\\ \\__/\\ \\/\\ \\/\\ \\______________________/ /\\/ /\\/ /\\__/ /\\/ /\\/ /\\_,\n (__/\\__/\\__/\\____/\\__/\\__/\\________________________/\\__/\\__/\\____/\\__/\\__/\\__)\n*/\n\n\n\n\n  return (\n    <div className=\"App\">\n      <TopNav gameAPI={gameAPI} currentPlayer={currentPlayer} hand={hand} players={players} gameOptions={gameOptions} cards={cards} />\n      <div className='App__body'>\n        <div className='App__body-temporarymessage'>{temporaryMessage}</div>\n        <div className='container'>\n          <div className='row'>\n            <div className=' DevInfo col-2 border small'>\n              <Debug gameOptions={gameOptions} hand={hand} gameAPI={gameAPI} stages={stages} />\n            </div>\n            <div className='col-5' key='gfds4'>\n              <CardsDeck cards={cards} players={players} setPlayers={setPlayers} characterCards={characterCards} districtCards={districtCards} hand={hand} stages={stages} setHand={setHand} currentPlayer={currentPlayer} playersAPI={playersAPI} setCharacterCards={setCharacterCards} setDistrictCards={setDistrictCards} cardsAPI={cardsAPI} gameAPI={gameAPI} />\n            </div>\n            <div className='col-5' key='35tt5'>\n              <Players players={players} currentPlayer={currentPlayer} crownPlayer={crownPlayer} cards={cards} setCards={setCards} cardsAPI={cardsAPI} playersAPI={playersAPI} />\n            </div>\n          </div>\n        </div>\n        \n      </div>\n      <Footer players={players} crownPlayer={crownPlayer} currentPlayer={currentPlayer} cards={cards} setCards={setCards} cardsAPI={cardsAPI} />\n      {\n       gameOptions.dev ? (\n        <div className='devtools'>\n          <h5>District Deck</h5>\n          <div className='row district-deck'>\n            { districtCards.map( card => <div className='small-card' key={ 'devcard'+card.ID }><Card card={card} /></div>) }\n          </div>\n          <h5>Chars Deck</h5>\n          <div className='row character-deck'>\n            { characterCards.map( card => <div className='small-card' key={ 'devcard'+card.ID }><Card card={card}/></div>) }\n          </div>\n        </div>\n\n\n       ) : null\n\n      }\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './css/index.scss';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}